 1 dynamic cut generation (M)
   1.1 add parameters for different cuts
   1.2 add mir, twomir
   1.3 try cuts when global lb keeps steady etc. 
 2 cut selection (A)
   2.1 use tightLower, tightUpper to get tighter bounds on variables from
       cglprobing
 3 preprocessing (M)
 4 primal heuristics (A)
   4.1 octane (M)
   4.2 everything else (A)
 5 Branching
   5.1 reliability (A)
   5.2 hotstart (A) D
   5.3 dynamic strong branching 
       (lim array in branch_close_to_half)
 6 Node selection (A)
 7 R.C. fixing (including root stuff) (A)
   7.1 carry rc fixing to child nodes (A)
   7.2 make loops for calculating tm->lb more efficient (A)
   7.3 print correct lb in print_tm_status (A)
 8 conflict graphs + implications + probing(A,M)
 9 sos branching (A)
10 scripts (A)
11 collect mip info (M)
   11.1 check integrality of obj-coeffs and if ub - lb < 1 etc. 
12 gams read (A)
13 sym infinity (A)
14 clp settings (A)
15 dynamic info/stats (A)
16 diving (A)
17 tail off (A)
18 priority lists (M)
19 memory overflow (A)
20 why are we 15x slower than cplex in branch and bound (A)
21 use column cuts from cgl. tie it up with (7.1).
22 check_row_effectiveness() sometimes does not delete constraints. it just
   makes rhs very big. causes problems with flowcover cuts.
23 replace array as data-structure for heap with linked lists.

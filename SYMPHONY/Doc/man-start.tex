%===========================================================================%
%                                                                           %
% This file is part of the documentation for the SYMPHONY MILP Solver.      %
%                                                                           %
% SYMPHONY was jointly developed by Ted Ralphs (tkralphs@lehigh.edu) and    %
% Laci Ladanyi (ladanyi@us.ibm.com).                                        %
%                                                                           %
% (c) Copyright 2000-2006 Ted Ralphs. All Rights Reserved.                  %
%                                                                           %
% SYMPHONY is licensed under the Common Public License. Please see          %
% accompanying file for terms.                                              %
%                                                                           %
%===========================================================================%

%FIXME: Where do we put this?
%\section{The LP Engine}

%SYMPHONY requires the use of a third-party callable library to solve the LP 
%relaxations once they are formulated. Native interfaces to ILOG's
%\htmladdnormallink{CPLEX}{http://www.cplex.com}$^{\copyright}$
%and IBM's
%\htmladdnormallink{OSL}{http://www-4.ibm.com/software/data/bi/osl/index.html}
%are available. As of Version 4.0, the Open Solver Interface, available from
%\htmladdnormallink{COIN}{http://www.coin-or.org}
%\begin{latexonly} 
%(\texttt{http://www.coin-or.org})
%\end{latexonly}.
%can be used to interface with most commonly available LP solvers. The list of
%solvers with OSI interfaces currently numbers eight and includes both
%commercial and open source alternatives. If the COIN libraries are used, make
%sure to set the proper paths in the SYMPHONY makefile.

%\section{Cut Generation}

%SYMPHONY now generates generic cutting planes using the Cut Generator Library,
%also available from 
%\htmladdnormallink{COIN}{http://www.coin-or.org}
%\begin{latexonly} 
%COIN (\texttt{http://www.coin-or.org})
%\end{latexonly}.
%The CGL can be used to generate cuts in cases where problem-specific cutting
%planes are not available or not implemented yet. 

This chapter is concerned with detailed instructions for building and
installing SYMPHONY, along with its associated libraries and applications.

\section{Installing the Binary Distribution}

For the users who only need the generic MILP solver or the SYMPHONY 
callable library to be used in their custom applications, there are 
binary distributions released for different compilers and platforms. 
Each distribution consists of an executable and libraries built from the 
source code of SYMPHONY version \VER.
 
You can obtain the SYMPHONY binary distribution from 
{\color{Brown}
\begin{verbatim}
 https://projects.coin-or.org/SYMPHONY
\end{verbatim}
}

The binaries are currently available for Linux and Windows. These binaries are
built with the following default options:
\begin{itemize}
\item The LP solver is the COIN LP solver (CLP).
\item Cut generation with COIN's Cut Generation Library (CGL) is enabled.
\item All libraries are static.
%\item Library linked with = CLP, CGL, COINUTILS, OSI, OSICLP, OSISYM, 
\item The optization level (Linux) is ``O2''. 
\item Only serial executables are included.
\end{itemize} 

Note that by building your own libraries and executables, you get additional
functionality, since we are not able to distribute an executable that links
with code distributed under the GNU General Public License, which includes
several useful libraries SYMPHONY can take advantage of. See Sections
\ref{getting_started_unix} and \ref{getting_started_windows} for instructions
for building SYMPHONY from source with other options, including the parallel
configuration.
% such as another LP
%solver, enabling GMPL reader or building SYMPHONY for parallel architectures.

\subsection{Installation for Unix-like environments}
\label{building-unix}

\begin{itemize}
\item Unpack the distribution with
{\color{Brown}
\begin{verbatim}
 tar xzvf symphony-\VER-XXX.tgz
\end{verbatim}
}
where \code{XXX} indicates the platform and the version of 
compiler used to build the distribution. 
Switch into the root directory of the unpacked distribution. 

\item First, test the executable by going to the \code{bin} directory and
typing 
{\color{Brown}
\begin{verbatim}
 ./symphony -F ../test/sample.mps
\end{verbatim}
}
\item To test the callable library, the distribution
includes sample files in \code{test} directory:  \\ \\
\underbar{milp.c}: This sample code is an implementation of a basic MILP
solver using SYMPHONY's C callable functions with user defined input (see
Section
\ref{callable_library}). To test the code, go to \code{test} directory and
type, {\color{Brown}
\begin{verbatim}
 make milp 
 milp
 \end{verbatim}}
\underbar{milpOsi.c}: This sample code is an implementation of a basic MILP 
solver using SYMPHONY's C++ callable functions (through OsiSym interface)
with user defined input (see Section \ref{OSI}). To test the code, 
go to \code{test} directory and type, 
{\color{Brown}
\begin{verbatim}
 make milpOsi
 milpOsi
 \end{verbatim}}
\end{itemize}

If everything is working properly, the libraries, executables and header files
can be installed in appropriate system directories if desired. This must be
done by hand. This step will be done automatically if building from source
using the automatic scripts provided (see below).

\subsection{Installation for Microsoft Visual C++}

Direct support is provided only for building in MS Visual Studio 6.0. 
Download and unpack the archive \code{symphony-\VER-winv6.zip} 
\begin{itemize}
\item First, test the executable by opening Windows Explorer and double-click
on {\color{Brown}\texttt{symphony.exe}} in the {\color{Brown}\texttt{bin}}
directory in the folder in which the distribution was unpacked. This should
open a Window in which the intereactive solver will appear. Type \code{help}
or \code{?} to see a list of available commands or see Chapter
\ref{API-overview} for instructions on using the interactive solver.

\item To test the callable library, the distribution includes sample codes
along with assocaited project files in the \code{test} directory. \\ \\
\underbar{milp.c}: This sample code is an implementation of a basic MILP
solver using SYMPHONY's C callable functions with user defined input (see
Section \ref{callable_library}). To test the code, either

\begin{itemize}
\item open the workspace \code{milp.dsw}, choose \code{Build milp.exe}
and then choose \code{Execute} from the \code{Build} menu, 
\end{itemize}
or
\begin{itemize}
\item open a command terminal (choose ``Run'' on the Start menu and type
``\code{cmd}'' in the dialogue box) and type 
{\color{Brown}
\begin{verbatim}
 msdev milp.dsw /make "all - debug"
 Debug/milp.exe
 \end{verbatim}
}
\end{itemize}
\underbar{milpOsi.c}: This sample code is an implementation of a basic MILP 
solver using SYMPHONY's C++ callable functions (through OsiSym interface)
with user defined input (see Section \ref{OSI}). To test the code, either 
\begin{itemize}
\item open the workspace \code{milpOsi.dsw}, 
choose \code{Build milpOsi.exe} and then 
\code{Execute} commands from the \code{Build} menu, 
\end{itemize}
or
\begin{itemize}
\item open a command terminal (choose ``Run'' on the Start menu and type
``\code{cmd}'' in the dialogue box) and type 
{\color{Brown}
\begin{verbatim}
 msdev milpOsi.dsw /make "all - debug"
 Debug/milpOsi.exe
 \end{verbatim}
}
\end{itemize}
\end{itemize}

% Applications??????

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Building From Source in Unix-like Environments}
\label{getting_started_unix}

SYMPHONY now uses the COIN-OR build system and the GNU autotools to automate
the build process. The build process should therefore be identical in all
Unix-like environments. These instructions will lead you through the steps
required to compile SYMPHONY as a generic MILP solver. This process will
create (1) a generic callable library that allows SYMPHONY to be called from
an application and (2) an executable that can be used as a stand-alone
application to solve MILPs written in either MPS or GMPL file format. SYMPHONY
can be further customized by implementing one of more than 50 callback
functions that change SYMPHONY's default execution of its algorithm. For
information on customizing SYMPHONY using callbacks, a quick start guide is
provided below.

\subsection{Downloading}

You can obtain the SYMPHONY source code either via the subversion repository
or in the form of daily tarballs. The recommended method is to use subversion
because it makes it easier to obtain updates. In a Unix-like environment (such
as Linux or CYGWIN), the following command may be used to obtain SYMPHONY from
source using SVN in most cases:
{\color{Brown}
\begin{verbatim}
 svn checkout https://projects.coin-or.org/svn/SYMPHONY/trunk/ COIN-SYMPHONY
\end{verbatim}
}
Alternatively, you can get point releases of the source code as a compressed
file from the download page of COIN-OR:
{\color{Brown}
\begin{verbatim}
 http://www.coin-or.org/Tarballs/
\end{verbatim}
}
The latest version of the source code is \VER, so you should download the file
{\color{Brown}\texttt{SYMPHONY-\VER.tgz}} and unpack the distribution with 
{\color{Brown}
\begin{verbatim}
 tar -xzf SYMPHONY-5.1.0.tgz
\end{verbatim}
} 
This will create a subdirectory called \code{SYMPHONY-\VER} containing
the distribution.

\subsection{Configuring}\label{configuring}

The first step is to run a configuration script that will allow the
compilation process to be customized for your environment. to perform this
step, switch into the root directory of the distribution and type
{\color{Brown}
\begin{verbatim}
 ./configure 
\end{verbatim}
} This will set up the default configuration files. If you want to override
the default settings, you can either run the configuration script with
command-line options or else modify the options in the file
{\color{Brown}\texttt{share/config.site}}. A complete list of options with
brief explanations can be seen both in the file
{\color{Brown}\texttt{share/config.site}} and by typing 
{\color{Brown}
\begin{verbatim}
 ./configure --help=recursive 
\end{verbatim}
}
See Figure \ref{conf_opts} for a list of options the user may want to set. 

\begin{figure}[htb]
\begin{tabular}{ll}
\hline
\texttt{--enable-debug} & compile all projects with debug options set \\
\texttt{--enable-debug-symphony} & compile only SYMPHONY project with debug options \\
\texttt{--enable-static} & build static libraries \\
\texttt{--enable-static-executable} &  create a complete static executable \\
\texttt{--enable-gnu-packages} & compile with GNU packages \\ 
& compile interactive optimizer with readline library \\
\hline
\texttt{--disable-cgl-cuts} & disable generic cut generation \\
\texttt{--enable-sensitivity-analysis} & compile in the sensitivity analysis features \\
\texttt{--enable-root-only} & process only the root node \\
\texttt{--enable-frac-branching} & compile in the fractional branching option \\
\texttt{--enable-tests}&  perform additional sanity checks (for debugging purposes) \\
\texttt{--enable-tm-tests }& perform more tests  \\
\texttt{--enable-trace-path}&  additional debugging options \\
\texttt{--enable-cut-check}& additional debugging options \\
\texttt{--enable-statistics}& additional statistics \\
\texttt{--enable-pseudo-costs}& enable some experimental pseudo-cost branching tools \\
\texttt{--enable-draw-graph} &  enable IGD graph drawing application \\
\hline
\texttt{ --with-XXX-incdir} &  specify the directory with the header files for the XXX package \\ 
&where XXX is one of LP solver packages: cplex, glpk, osl, soplex, \\ 
& xpress \\
\texttt{--with-XXX-lib} &  specify the flags to link with the library  
XXX package \\ 
&where XXX is one of LP solver packages: cplex, glpk, osl, soplex, \\ 
& xpress \\
\texttt{--with-lp-solver[=lpsolver]} &  specify the LP solver in small 
letters (default lpsolver=clp) \\
\texttt{ --with-gmpl} &  compile with GMPL reader (requires 
\texttt{--with-glpk-incdir} and \\ &
\texttt{--with-glpk-lib} options to be set) \\
\texttt{--with-osi-interface} &  compile with SymOsi interface \\
\texttt{--with-application} &  compile the application library \\
\hline
\texttt{--enable-openmp} &   compile in OpenMP features \\
\texttt{--with-pvm } &  compile in parallel architecture (assuming that pvm is \\ 
&installed and the variable PVM\_ROOT is defined.) \\
\texttt{--without-cg} &  compile without cut generator module \\
\texttt{--without-cp} &  compile without cut pool module \\
\texttt{--without-lp} &  compile without LP solver module \\
\texttt{--without-tm} &  compile without tree manager module
\end{tabular}
\caption{A list of useful configuration options \label{conf_opts}}
\end{figure}

In order to enable or disable an option, either update the file 
\code{share/config.site} or add the option as an argument to configuration script. 
As an instance for the second case, running 
{\color{Brown}
\begin{verbatim}
 ./configure --enable-debug
\end{verbatim}
}
will set the configuration to compile the source files with debugging
flag. 

\subsection{Building}\label{building}

After configuring, the code can be built by typing the commands
{\color{Brown}
\begin{verbatim}
 make
 make install
\end{verbatim}
} This will first create the required libraries and binaries and then will
install them. By default, the library {\color{Brown}\texttt{libSym}} and the
executable {\color{Brown}\texttt{symphony}} will be installed to the
{\color{Brown}\texttt{lib/}} and {\color{Brown}\texttt{bin/}} directories. To
install in another directory, use the option
{\color{Brown}\texttt{--prefix=DIR}} to the {\color{Brown}\texttt{configure}}
command.

After compilation, the SYMPHONY library, together with the header files in the
subdirectory {\color{Brown}\texttt{include/}}, can then be used to call
SYMPHONY from any C/C++ code. The API for this is described in
Chapter~\ref{API-overview}. The executable can also be used for solving
generic MILP problems in MPS and GMPL format. In order to read GMPL files, you
will need to have GLPK (\url{http://www.gnu.org/software/glpk/}) installed and
SYMPHONY must be configured with {\color{Brown}
\begin{verbatim}
 ./configure --with-gmpl --with-glpk-lib[=GLPK library] 
             --with-glpk-incdir[=GLPK include dir] 
\end{verbatim}
}
For more pwerful modeling interface, FlopC++ can also be used to obtain a
capability similar to ILOG's Concert technology for building math programming
models (see SYMPHONY/Examples/FLOPC++). 

To test SYMPHONY after building, type
{\color{Brown}
\begin{verbatim}
 make test
\end{verbatim}
} to execute an automated unit test. To test out the optimizer manually. a
sample MPS file called \code{sample.mps} and a sample GMPL/AMPL file called
{\color{Brown}\texttt{sample.mod}} together with its data file
{\color{Brown}\texttt{sample.dat}} are included with the distribution. You can
use either the command-line or the interactive optimizer. To solve the sample
MPS model, type {\color{Brown}
\begin{verbatim}
 bin/symphony -F SYMPHONY/Datasets/sample.mps
\end{verbatim}
} To solve the GMPL model, use the \code{-F} switch to specify the file name
and the \code{-D} for the data file name if the input is in GMPL/AMPL format,
i.e., type 
{\color{Brown}
\begin{verbatim}
 bin/symphony -F SYMPHONY/Datasets/sample.mod -D SYMPHONY/Datasets/sample.dat
\end{verbatim}}
For more MPS data files for further testing, see the MIPLIB library in the
\code{Data/} subdirectory. To run the interactive optimizer, execute SYMPHONY
without any command-line arguments, i.e., type
{\color{Brown}
\begin{verbatim}
  bin/symphony 
\end{verbatim}}
and then type \code{help} or \code{?} to see a list of available commands.
After the SYMPHONY library and the executable are compiled and tested, you
can type
{\color{Brown}
\begin{verbatim}
 make clean 
\end{verbatim}}
if you want to save disk space. That's it! Now you are ready to use SYMPHONY
callable library or solve generic MILP problems through the executable.

\subsection{Building for parallel architectures}

\subsubsection{Shared-memory architectures}

To compile a shared memory version of SYMPHONY, simply use an OpenMP compliant
compiler. Version \VER\  has been tested with gcc 4.2, and should work by
configuring with
{\color{Brown}
\begin{verbatim}
 ./configure --enable-openmp
\end{verbatim}
}
Follow the instructions above for building and testing. To invoke SYMPHONY
from the command-line with multiple threads, specify the number of threads
with the \code{-p} option, i.e.,
{\color{Brown}
\begin{verbatim}
 bin/symphony -p 2 -F SYMPHONY/Datasets/sample.mps
\end{verbatim}
}

\subsubsection{Distributed-memory architectures}
\label{distributed-build}

\paragraph{Installing PVM.}
\label{PVM}
To compile a distributed application, it is necessary that PVM be installed
either in the system path or in the directory pointed to by the environment
variable \code{PVM\_ROOT} (this can be your homedirectory if PVM is not
already installed on your network). To install PVM yourself, the current
version can be obtained at \texttt{
\htmladdnormallink{http://www.csm.ornl.gov/pvm/}
{http://www.csm.ornl.gov/pvm/}}. It should compile and install without
problems on most architectures. You will have to make a few modifications to
your \code{.cshrc} file, such as defining the \code{PVM\_ROOT} environment
variable, but this is all explained clearly in the PVM documentation. Note
that all executables (or at least a link to them) must reside in the \code{\$PVM\_ROOT/bin/\$PVM\_ARCH} directory in order for parallel processes to be
spawned correctly. The environment variable \code{PVM\_ARCH} is set in your
\code{.cshrc} file and contains a string representing the current architecture
type. To run a parallel application, you must first start up the daemon on
each of the machines you plan to use in the computation. How to do this is
also explained in the PVM documentation.

\paragraph{Configuring.}

To configure for a parallel build with the default parallel configuration,
invoke the configuration script as follows: {\color{Brown}
\begin{verbatim}
 ./configure --with-pvm
\end{verbatim}
} 
Note that there are a number of different parallel configurations (see Chapter
\ref{SYMPHONY-modules} for an overview of SYMPHONY's parallel modules). The
default configuration is to build two parallel modules, the first consisting
of the master, tree management, and cut management modules, while the second
one consists of the node processing, and cut generation modules. To build in
another configuration, there are four variables that control which modules run
as separate executables and which are called directly in serial fashion. The
variables are as follows:
\begin{description}
        \item[] \code{--with-cg}: If set to \code{yes}, then the cut generator
        function will be called directly from the LP in serial
        fashion, instead of running as a separate executable. This is
        desirable if cut generation is quick and running it in
        parallel is not worth the price of the communication overhead.
        \item[] \code{--with-cp}: If set to \code{yes}, then the cut
        pool(s) will be maintained as a data structure auxiliary to the
        tree manager. 
        \item[] \code{--with-lp}: If set to \code{yes}, then the LP
        functions will be called directly from the tree manager. When
        running the distributed version, this
        necessarily implies that there will only be one active
        subproblem at a time, and hence the code will essentially be
        running serially. In the shared-memory version, however, the
        tree manager will be threaded in order to execute subproblems 
        in parallel.
        \item[] \code{--with-tm}: If set to \code{yes}, then the tree
        will be managed directly from the master process. This is only
        recommended if a single executable is desired (i.e.~the three
        other variables are also set to true). A single executable is
        extremely useful for debugging purposes.
\end{description}
These variables can be set in virtually any combination, though some
don't really make much sense. Note that in a few user functions that
involve process communication, there will be different versions for
serial and parallel computation. This is accomplished through the use
of \code{\#ifdef} statements in the source code. This is well documented
in the function descriptions and the in the source files containing
the function stubs.

\paragraph{Building.}

Once configured, follow the build instructions in Section \ref{building-unix}
to build the code. Note that this will also compile the sequential version.
Make sure there are links from your
\code{\$PVM\_ROOT/bin/\$PVM\_ARCH} subdirectoryto each of the executables in
your \code{bin/} directory, as required by PVM. In order to keep track of
the various possible configurations, executable and their corresponding
libraries are named as follows. The name of the master module, along with all
other modules compiled in with the master, is set in the makefile. For the
other modules, default names are typically used, since these names have to be
hard-coded in order for PVM to correctly spawn the corresponding processes. In
the fully distributed version, the default names are \code{tm}, \code{lp},
\code{cg}, and \code{cp}. For other configurations, the executable name is
a combination of all the modules that were compiled together joined by
underscores. In other words, if the LP and the cut generator modules were
compiled together (i.e.,~\code{--with-cg} set to \code{yes}), then the executable
name would be \code{lp\_cg} and the corresponding library file would be
called \code{liblp\_cg.a}. You can rename the executables as you like.
However, if you are using PVM to spawn the modules, as in the fully
distributed version, you must set the parameters \code{*\_exe} in the parameter
file to the new executable names. See Section
\ref{tm_params} for information on setting parameters in the parameter file.

To test the parallel version, first start the PVM daemon by typing
\code{pvm} on the command line and then typing \code{quit}. As above,
invoke SYMPHONY using the sample MPS file called \code{sample.mps} included
with the distribution. To specify the file name, use the \code{-F}
command-line option, i.e., in the root directory, type
{\color{Brown}
\begin{verbatim}
 bin/symphony_m_$(EXT) -F SYMPHONY/Datasets/sample.mps 
\end{verbatim}
} where \code{\$(EXT)} is an extension to be added according to the chosen
configuration of the modules. 

\subsection{Building SYMPHONY Applications}
\label{build_appl}

There are a number of sample applications available as examples of how to do
development with SYMPHONY. These include solvers for the matching problem, the
set partitioning problem (simple and advanced versions), the vehicle routing
and traveling salesman problems, the mixed postman problem, multi-criteria
knapsack problem and, capacitated network routing problem. These applications
are distributed as separate packages and can be downloaded either from
\texttt{\htmladdnormallink{http://www.projects.coin-or/SYMPHONY}{http://www.projects.coin-or/SYMPHONY/}} or from 
\texttt{\htmladdnormallink{http://www.branchandcut.org/SYMPHONY}{http://www.branchandcut.org/SYMPHONY/}}. There is also a white paper that guides the
user through the development of the matching solver. These applications are
contained in the \code{SYMPHONY/Applications/} subdirectory in the
distribution. For instructions on developing your own application with
SYMPHONY, see Chapter \ref{SYMPHONY-development}.

In order to compile SYMPHONY's applications in Unix-like environments, you
must first compile a version of the callable library with hooks for the
callback functions. {\color{Brown}
\begin{verbatim}
 ./configure --with-applications 
 make 
 make install
\end{verbatim}
}
This will create the application library called \code{libSymAppl} to be used while
building custom applications. Note that that sequential version library and
executable will also be made and installed.

After building the library, go to one of the application subdirectories in the
\code{SYMPHONY/Applications/} directory and type \code{make} there. For
more information, including the parallel configuration instructions, see the
INSTALL file of the corresponding application.

\section{Building From Source Using Microsoft Visual C++}
\label{getting_started_windows}

Here is a sketch outline of how to compile SYMPHONY in MS Windows.
These instructions will lead you through the steps required to compile
SYMPHONY as a generic MILP solver. Direct support
is provided for compilation with MS Visual Studio 6.0. Compilation for other
compilers should also be possible. Note that the Windows version has some
limitations. Detailed timing information is not currently provided. Support is
only provided for running in sequential mode at this time.

First, download \code{SYMPHONY-\VER.tgz} and unpack the archive. This will
create a subdirectory called \code{SYMPHONY-\VER} containing all the source
files.You now 
have three options. You can either compile on the command-line using automated 
MSDEV build system or NMAKE utility or you can use the provided projects and 
workspaces. Compiling on the command-line is somewhat easier since it requires 
only typing a single command or editing the makefile. 

\subsection{Using the MSDEV Utility}
\label{using_msdev}
\begin{itemize}
\item Open a command terminal (choose ``Run'' on the Start menu and type
``\code{cmd}'' in the dialogue box). Go to the \code{Win32\bs v6}
directory and type 
{\color{Brown}
\begin{verbatim}
 msdev symphony.dsw /make all
\end{verbatim}
}
This will create both the debug and release versions of SYMPHONY. If you 
want to compile only one of them, type
{\color{Brown}
\begin{verbatim}
 msdev symphony.dsw /make "all - debug"
\end{verbatim}
}
or 
{\color{Brown}
\begin{verbatim}
 msdev symphony.dsw /make "all - release"
\end{verbatim}
}
For each command, the library \code{libSymphony.lib} and the executable 
\code{symphony} will be created in \code{Debug} and/or \code{Release}
directories.  The library, together with the header files in 
\code{SYMPHONY\bs include\bs}, can then be 
used to call SYMPHONY from any C/C++ code. The API for calling SYMPHONY is 
described in Section \ref{callable_library}.

\item Test the executable by opening Windows Explorer and double-clicking
on {\color{Brown}\texttt{symphony.exe}} in the
{\color{Brown}\texttt{Debug\bs}} subdirectory. This should open a Window in
which the intereactive solver will appear. Type \code{help} or \code{?} to see
a list of available commands or see Chapter
\ref{API-overview} for instructions on using the interactive solver.

\item If you modify the source code of SYMPHONY, type 
{\color{Brown}
\begin{verbatim}
 msdev symphony.dsw /make all /rebuild
\end{verbatim}
}
in order to clean and rebuild everything.
\end{itemize} 

\subsection{Using the NMAKE Utility}
\label{using_nmake}

\begin{itemize}
\item Go to \code{Win32/v6} directory and edit the \code{sym.mak} 
makefile to reflect 
your environment. This involves specifying the LP solver to be used, 
assigning some variables and  setting various paths. Only minor edits 
should be required. An explanation of what has to be set is contained in the 
comments in the makefile.  Note that, you have to first create the COIN 
libraries \ptt{Cgl}, \ptt{Clp}, \ptt{Osi}, \ptt{OsiClp} and \ptt{CoinUtils} 
which reside in \code{Win32/v6} directory.

\item Once configuration is done, open a command line terminal and type 
{\color{Brown}
\begin{verbatim}
 nmake /f sym.mak
\end{verbatim}
}
This will make the SYMPHONY library \code{libSymphony.lib} and the executable 
\code{symphony} in \code{Debug} directory. The library, together with the 
header files in \code{SYMPHONY\bs include\bs}, can then be used to call 
SYMPHONY from any C/C++ code. The API for calling SYMPHONY is described in 
Section \ref{callable_library}.

\item Test the executable by opening Windows Explorer and double-clicking
on {\color{Brown}\texttt{symphony.exe}} in the
{\color{Brown}\texttt{Debug\bs}} subdirectory. This should open a Window in
which the intereactive solver will appear. Type \code{help} or \code{?} to see
a list of available commands or see Chapter \ref{API-overview} for
instructions on using the interactive solver.

\end{itemize}

\subsection{Using the MSVC++ Workspace}

\begin{itemize}

\item Go to \code{Win32\bs v6} directory and open the workspace 
\code{symphony.dsw}. 

\item Note that there are a number of additional preprocessor definitions that
control the functionality of SYMPHONY. These definitions are described in
\code{sym.mak}, a Unix-style makefile included in the distribution. To 
enable the functionality associated with a particular definition, simply add 
it to the list of definitions of \code{libSymphony} project together with 
the required libraries and paths. For instance, if you 
want to enable GMPL reader option, you need to
\begin{itemize}
  \item add the directory of the header files of GLPK to the include 
files path
  \item add \code{USE\_GLPMPL} to the defines
  \item add the GLPK library to the workspace
\end{itemize}
\item Make sure that the project \code{symphony} is set as the active 
project from the Project/Set Active menu. Choose 
\code{Build symphony.exe} from the Build menu. This should successfully 
build the SYMPHONY library and the corresponding executable.

\item To test the executable, right click on the symphony project, go to the
\code{Debug} tab and set the program arguments to 
{\color{Brown}
\begin{verbatim}
 -F ..\..\SYMPHONY\Datasets\sample.mps 
\end{verbatim}
}
Note that command-line switches are Unix-style. If you want to use the 
interactive optimizer, leave this tab empty. 

4. Now choose \code{Execute} from the Build menu and the solver should 
solve the given sample problem. If you have not specified the sample problem, 
then the interactive optimizer should start. In this case, 
type \code{help} or \code{?} to see a list of available commands
\end{itemize}

Note that there is some functionality missing from the Windows version. Most
prominently, the timing functions do not work. This functionality
should be easy to add---let me know if you are interested in doing it and I
will give you all the help I can. In addition, the Windows version will only
run in sequential mode for a variety of reasons. However, it should be
relatively easy to get it running in parallel if you can get PVM working under
Windows. Let me know if you are interested.

%FIXME: Do we describe how to build an application?
%\subsection{Building SYMPHONY Applications}
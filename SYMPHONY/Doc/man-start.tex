%===========================================================================%
%                                                                           %
% This file is part of the documentation for the SYMPHONY MILP Solver.      %
%                                                                           %
% SYMPHONY was jointly developed by Ted Ralphs (tkralphs@lehigh.edu) and    %
% Laci Ladanyi (ladanyi@us.ibm.com).                                        %
%                                                                           %
% (c) Copyright 2000-2006 Ted Ralphs. All Rights Reserved.                  %
%                                                                           %
% SYMPHONY is licensed under the Common Public License. Please see          %
% accompanying file for terms.                                              %
%                                                                           %
%===========================================================================%

This chapter is concerned with detailed instructions for building and
installing \BB, along with its associated libraries and applications.

\section{Installing the Binary Distribution}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Building from source in Unix-like environments}
\label{getting_started_unix}

SYMPHONY now uses the COIN-OR build system and the GNU autotools to automate
the build process. The build process should therefore be identical in all
Unix-like environments. These instructions will lead you through the steps
required to compile SYMPHONY as a generic MILP solver. This process will
create (1) a generic callable library that allows SYMPHONY to be called from
an application and (2) an executable that can be used as a stand-alone
application to solve MILPs written in either MPS or GMPL file format. SYMPHONY
can be further customized by implementing one of more than 50 callback
functions that change SYMPHONY's default execution of its algorithm. For
information on customizing SYMPHONY using callbacks, a quick start guide is
provided below.

\subsection{Downloading}

You can obtain the SYMPHONY source code either via the subversion repository
or in the form of daily tarballs. The recommended method is to use subversion
because it makes it easier to obtain updates. In a Unix-like environment (such
as Linux or CYGWIN), the following command may be used to obtain SYMPHONY from
source using SVN in most cases:
{\color{Brown}
\begin{verbatim}
svn checkout https://projects.coin-or.org/svn/SYMPHONY/trunk/ COIN-SYMPHONY
\end{verbatim}
}
Alternatively, you can get a daily snapshot of the source code as a tarball
from the download page of COIN-OR:
{\color{Brown}
\begin{verbatim}
http://www.coin-or.org/Tarballs/
\end{verbatim}
}
If the code is obtained as a tarball, unpack the distribution with 
{\color{Brown}
\begin{verbatim}
tar -xzf SYMPHONY_XXX.tgz
\end{verbatim}
}
where ``\texttt{XXX}'' is the date the snapshot is taken. This will create a
subdirectory called \texttt{SYMPHONY\_XXX/} containing the distribution.

\subsection{Configuring}

The first step is to run a configuration script that will allow the
compilation process to be customized for your environment. to perform this
step, switch into the root directory of the distribution and type
{\color{Brown}
\begin{verbatim}
./configure 
\end{verbatim}
}
This will set up the default configuration files. If you want to override the
default settings, you can either run the configuration script with
command-line options or else modify the options in the file
'share/config.site'. A complete list of options with brief
explanations can be seen both in the file 'share/config.site' and by typing
{\color{Brown}
\begin{verbatim}
 ./configure --help=recursive 
\end{verbatim}
}
See Figure \ref{conf_opts} for a list of options the user may want to set. 

\begin{figure}[htb]
\begin{tabular}{ll}
\hline
\texttt{--enable-debug} & compile all projects with debug options set \\
\texttt{--enable-debug-symphony} & compile only SYMPHONY project with debug options \\
\texttt{--enable-static} & build static libraries \\
\texttt{--enable-static-executable} &  create a complete static executable \\
\texttt{--enable-gnu-packages} & compile with GNU packages \\ 
& compile interactive optimizer with readline library \\
\hline
\texttt{--disable-cgl-cuts} & disable generic cut generation \\
\texttt{--enable-sensitivity-analysis} & compile in the sensitivity analysis features \\
\texttt{--enable-root-only} & process only the root node \\
\texttt{--enable-frac-branching} & compile in the fractional branching option \\
\texttt{--enable-tests}&  perform additional sanity checks (for debugging purposes) \\
\texttt{--enable-tm-tests }& perform more tests  \\
\texttt{--enable-trace-path}&  additional debugging options \\
\texttt{--enable-cut-check}& additional debugging options \\
\texttt{--enable-statistics}& additional statistics \\
\texttt{--enable-pseudo-costs}& enable some experimental pseudo-cost branching tools \\
\texttt{--enable-draw-graph} &  enable IGD graph drawing application \\
\hline
\texttt{ --with-XXX-incdir} &  specify the directory with the header files for the XXX package \\ 
&where XXX is one of LP solver packages: cplex, glpk, osl, soplex, \\ 
& xpress \\
\texttt{--with-XXX-lib} &  specify the flags to link with the library  
XXX package \\ 
&where XXX is one of LP solver packages: cplex, glpk, osl, soplex, \\ 
& xpress \\
\texttt{--with-lp-solver[=lpsolver]} &  specify the LP solver in small 
letters (default lpsolver=clp) \\
\texttt{ --with-gmpl} &  compile with GMPL reader (requires 
\texttt{--with-glpk-incdir} and \\ &
\texttt{--with-glpk-lib} options to be set) \\
\texttt{--with-osi-interface} &  compile with SymOsi interface \\
\texttt{--with-application} &  compile the application library \\
\hline
\texttt{--enable-openmp} &   compile in OpenMP features \\
\texttt{--with-pvm } &  compile in parallel architecture (assuming that pvm is \\ 
&installed and the variable PVM\_ROOT is defined.) \\
\texttt{--without-cg} &  compile without cut generator module \\
\texttt{--without-cp} &  compile without cut pool module \\
\texttt{--without-lp} &  compile without LP solver module \\
\texttt{--without-tm} &  compile without tree manager module
\end{tabular}
\caption{A list of useful configuration options \label{conf_opts}}
\end{figure}

In order to enable or disable an option, either update the file 
'share/config.site' or add the option as an argument to configuration script. 
As an instance for the second case, running 
{\color{Brown}
\begin{verbatim}
./configure --enable-debug
\end{verbatim}
}
will set the configuration to compile the source files with debugging
flag. 

\subsection{Building}\label{building}

After configuring, the code can be built by typing the commands
{\color{Brown}
\begin{verbatim}
make
make install
\end{verbatim}
}
This will first create the required libraries and binaries and then will
install them. By default, the library \texttt{libSym} and the executable
\texttt{symphony} will be installed to the \texttt{lib/} and \texttt{bin/}
directories.

After compilation, the SYMPHONY library, together with the header files in the
subdirectory \texttt{include/}, can then be used to call SYMPHONY from any
C/C++ code. The API for this is described in Chapter~\ref{API-overview}. The
executable can also be used for solving generic MILP problems in MPS and GMPL
format. In order to read GMPL files, you will need to have GLPK 
(\url{http://www.gnu.org/software/glpk/}) installed and
SYMPHONY must be configured with
{\color{Brown}
\begin{verbatim}
./configure --with-gmpl --with-glpk-lib[=GLPK library] 
            --with-glpk-incdir[=GLPK include dir] 
\end{verbatim}
}
For more pwerful modeling interface, FlopC++ can also be used to obtain a
capability similar to ILOG's Concert technology for building math programming
models (see SYMPHONY/Examples/FLOPC++). 

To test SYMPHONY after building, type
{\color{Brown}
\begin{verbatim}
make test
\end{verbatim}
}
to execute an automated unit test. To test out the optimizer manually. a
sample MPS file called "sample.mps" and a sample GMPL/AMPL file called
"sample.mod" together with its data file "sample.dat" are included with the
distribution. You can use either the command-line or the interactive
optimizer. To solve the sample MPS model, type 
{\color{Brown}
\begin{verbatim}
bin/symphony -F SYMPHONY/Datasets/sample.mps
\end{verbatim}
}
To solve the GMPL model, use the "-F" switch to specify the file
name and the "-D" for the data file name if the input is in GMPL/AMPL format,
i.e., type
{\color{Brown}
\begin{verbatim}
bin/symphony -F SYMPHONY/Datasets/sample.mod -D SYMPHONY/Datasets/sample.dat
\end{verbatim}
}
For more MPS data files for further testing, see the MIPLIB library in the
Data/ subdirectory. To run the interactive optimizer, execute SYMPHONY without
any command-line arguments, i.e., type
{\color{Brown}
\begin{verbatim}
 bin/symphony 
\end{verbatim}
}
and then type "help" or "?" to see a list of available commands.

After the SYMPHONY library and the executable are compiled and tested, you
can type
{\color{Brown}
\begin{verbatim}
make clean 
\end{verbatim}
}
if you want to save disk space. That's it! Now you are ready to use SYMPHONY
callable library or solve generic MILP problems through the executable.

\section{Building for shared-memory multiprocessor architecture}

To compile a shared memory version of SYMPHONY, simply use an OpenMP compliant
compiler. Version 5.1 has been tested with gcc 4.2, and should work by
configuring with
{\color{Brown}
\begin{verbatim}
./configure -enable-openmp
\end{verbatim}
}
Follow the instructions above for building and testing. To invoke SYMPHONY
from the command-line with multiple threads, specify the number of threads
with the \texttt{-p} option, i.e.,
{\color{Brown}
\begin{verbatim}
bin/symphony -p 2 -F SYMPHONY/Datasets/sample.mps
\end{verbatim}
}
\section{Building for distribuited-memory architectuires}

If you wish to compile a distributed version of the code, first make sure
you have PVM installed. You can obtain it from
\url{http://www.csm.ornl.gov/pvm/}. To configure for a parallel build, invoke
the configuration script as follows:
{\color{Brown}
\begin{verbatim}
./configure --with-pvm
\end{verbatim}
}
Be sure that PVM is installed either in system path or that you have the
environment variable \texttt{PVM\_ROOT} set properly. Note that there are a
number of different parallel configurations. The default configuration is to
build two parallel modules. The first one consists of the master, tree
management, and cut management modules, while the second one consists of the
node processing, and cut generation modules. For other configuration options,
see the share/config.site file.

Follow the build instructions above to build the code. Note that this will
also compile the sequential version. Make sure there are links from your
\texttt{\$PVM\_ROOT/bin/\$PVM\_ARCH} subdirectoryto each of the executables in
your \texttt{bin/} directory. This is required by PVM.

To test the parallel version, first start the PVM daemon by typing
\texttt{pvm} on the command line and then typing \texttt{quit}. As above,
invoke SYMPHONY using the sample MPS file called \texttt{sample.mps} included
with the distribution. To specify the file name, use the \texttt{-F}
command-line option, i.e., in the root directory, type
{\color{Brown}
\begin{verbatim}
bin/symphony_m$(EXT) -F SYMPHONY/Datasets/sample.mps 
\end{verbatim}
}
where \texttt{\$(EXT)} is an extension to be added according to the chosen
module dependencies. To obtain more MPS data files for further testing,
download the MIPLIB library.

\section{Building a SYMPHONY Application}

In order to compile SYMPHONY's applications, you must first compile the 
application-specific library with
{\color{Brown}
\begin{verbatim}
./configure --with-applications
make 
make install
\end{verbatim}
}
This will create the application library called 'libSymAppl' to be used while
building custom applications. Note that that sequential version library and
executable will also be made and installed.

After building the library, go to one of the application subdirectories in the
\texttt{SYMPHONY/Applications/} directory and type \texttt{make} there. For
more information, including the parallel configuration instructions, see the
INSTALL file of the corresponding application.

\section{Building from source Using the Microsoft Visual C++ compiler}
\label{getting_started_windows}

Here is a sketch outline of how to compile \BB\ in MS Windows. Direct support
is provided for compilation with MS Visual Studio 6.0. Compilation for other
compilers should also be possible. Note that the Windows version has some
limitations. Detailed timing information is not currently provided. Support is
only provided for running in sequential mode at this time.

First, download \texttt{SYMPHONY-5.1.zip} and unzip the archive. This will
create a subdirectory called \texttt{SYMPHONY-5.1} containing all the source
files. You now have two options. You can either compile on the command-line,
using the MSVC++ makefile called
\texttt{sym.mak} in the \texttt{SYMPHONY-5.1$\backslash$WIN32} subdirectory or 
you can use the provided projects and workspaces. Compiling on the command-line 
is somewhat easier since it requires only editing the makefile and typing a
single command.

\subsection{Using the NMAKE Utility}
\label{using_nmake}

\begin{itemize}

\item Edit the file
\texttt{SYMPHONY-5.1$\backslash$WIN32$\backslash$sym.mak} makefile to
reflect your environment. This involves specifying the LP solver to be used
and various paths. Only minor edits should be required. An explanation of what
has to be set is contained in the comments in the makefile.

\item To use many of the new capabilities of \BB, you must have installed
the \emph{\htmladdnormallink{COIN}{http://www.ccs.ornl.gov/pvm/}} optimization
libraries
\begin{latexonly} 
COIN optimization libraries, available from
\texttt{http://www.coin-or.org} 
\end{latexonly}. By default \BB\ is 
set to use COIN LP solver, \texttt{CLP}, COIN Open Solver Interface, 
\texttt{OSI}, and COIN Cut Generation Library, \texttt{CGL}. To keep this 
configuration, you should install \texttt{OSI}, \texttt{CGL}, \texttt{CLP} 
and additionally, the Coin utilities (under COIN$\backslash$Coin).The path to 
the COIN libraries must be specified in 
\texttt{SYMPHONY-5.1$\backslash$WIN32$\backslash$sym.mak}.

\item If you wish to read \texttt{GMPL/AMPL} files, you will have to install the 
Gnu Linear Programming Kit (GLPK), which contains a parser for GMPL/AMPL
files. The path to the GLPK libraries must be specified in the makefile.

\item Once configuration is done, type \texttt{nmake /f sym.mak} at the
command prompt in the \\
\texttt{SYMPHONY-5.1$\backslash$WIN32} subdirectory. 
This will first make the \BB\ library (sequential version):
\texttt{SYMPHONY-5.1$\backslash$WIN32$\backslash$Debug$\backslash$symphonyLib.lib}. This library together with the header files in the subdirectory
(\texttt{SYMPHONY-5.1$\backslash$include}) can then be
be used to call \BB\ from any C code. The \texttt{API} for this is 
described in section \ref{API}.
After compiling the \BB\ library, the default \texttt{main} function will 
be compiled and linked with the the callable library to form an executable
called \texttt{symphony.exe} to be used for solving generic MILP problems 
in \texttt{MPS} or \texttt{GMPL} format. The executable will be created in the
\texttt{SYMPHONY-5.1$\backslash$WIN32$\backslash$Debug} subdirectory.

\item To test the executable, type \texttt{symphony.exe -F 
..$\backslash$..$\backslash$sample.mps} at a command prompt in the
\texttt{SYMPHONY-5.1$\backslash$WIN32$\backslash$Debug} subdirectory.

\end{itemize}

\subsection{Using the MSVC++ Workspace}

\begin{itemize}

\item In MS Visual C++ 6.0, open the workspace
\texttt{SYMPHONY-5.1$\backslash$WIN32$\backslash$symphony.dsw}. 
Note that there are two projects, one called \texttt{symphony} and the other 
called
\texttt{symphonyLib}. The \texttt{symphonyLib} project compiles the source 
code to create the callable library: \texttt{symphonyLib.lib}. The 
\texttt{symphony} project compiles the main  function and links that with the c
allable library to create the executable: \texttt{symphony.exe}. 

\item To use many of the new capabilities of \BB, you must have installed
the \htmladdnormallink{COIN}{http://www.ccs.ornl.gov/pvm/} optimization
libraries 
\begin{latexonly} 
COIN optimization libraries, available from
\texttt{http://www.coin-or.org} 
\end{latexonly}. By default \BB\ is 
set up to use COIN LP solver, \texttt{CLP}, COIN Open Solver Interface, 
\texttt{OSI}, and COIN Cut Generation Library, \texttt{CGL}. To keep this 
configuration, you should install \texttt{OSI}, \texttt{CGL}, \texttt{CLP} 
and additionally, the Coin utilities (under COIN$\backslash$Coin).
The default location for COIN is C:$\backslash$COIN$\backslash$.

\item By default, \BB\ is set up to use the OSI CLP interface. To see this
check the following settings:

\begin{itemize}

\item \texttt{\_\_OSI\_CLP\_\_} is defined in the preprocessor
definitions of both \texttt{symphony} and \texttt{symphonyLib} projects 
(right-click on one of the projects, and then choose \texttt{Settings --> C/C++
--> Preprocessor} in the category drop-down menu).

\item Paths to the include files of COIN utilities (Coin), OSI, OSI\_CLP, and
CLP are specified in the same settings window as for the preprocessor
definitions. Note that the Coin, OSI, and OSI\_CLP and CLP include 
directories are assumed to be in \texttt{C:$\backslash$COIN$\backslash$Coin},
\texttt{C:$\backslash$COIN$\backslash$Osi},
\texttt{C:$\backslash$COIN$\backslash$Osi$\backslash$OsiClp} and 
\texttt{C:$\backslash$COIN$\backslash$Clp},
directories, respectively. If they are not, make sure that you have set the
correct paths in both projects before compiling.

\item The \texttt{symphony} project is dependent on the \texttt{symphonyLib} 
project (see the dependencies in \texttt{Project --> Dependencies}) 
and it includes the necessary libraries: \texttt{symphonyLib}, 
\texttt{coinLib}, \texttt{osiLib}, \texttt{osiClpLib} and \texttt{clpLib} 
(solver library).

\end{itemize}

If you want to use the native CPLEX or OSL interface 
(without downloading COIN) or a solver other than CLP:

\begin{itemize}

\item If another OSI interface, change the preprocessor
definition in both projects from \texttt{\_\_OSI\_CLP\_\_} to 
\texttt{\_\_OSI\_XXX\_\_} ,
where \texttt{XXX} is replaced by the desired solver's acronym (e.g.,
\texttt{\_\_OSI\_CPLEX\_\_}, \texttt{\_\_OSI\_GLPK\_\_},
\texttt{\_\_OSI\_OSL\_\_}, etc.). Otherwise, change it to either
\texttt{\_\_CPLEX\_\_} or \texttt{\_\_OSL\_\_} in both projects.

\item Change the path definitions of the include files: for instance, if you 
want to use \texttt{\_\_OSI\_CPLEX\_\_}, define
\texttt{C:$\backslash$COIN$\backslash$Osi$\backslash$OsiCpx} and 
\texttt{C:$\backslash$ILOG$\backslash$cplex81$\backslash$include$\backslash$ilcplex} 
(assuming it is installed there) instead of the OSI CLP and CLP path 
definitions. Or, if you want to use \texttt{\_\_OSI\_OSL\_\_}, define 
\texttt{C:$\backslash$COIN$\backslash$Osi$\backslash$OsiOsl} and 
\texttt{C:$\backslash$ProgramFiles$\backslash$IbmOslV3Lib$\backslash$osllib}
(assuming OSL is installed there) instead of the OSI CLP and CLP path 
definitions. If you want to use the native CPLEX or OSL interface, 
delete all the path  definitions (you are not required to have COIN or OSI), 
and just add the path definitions for the CPLEX or OSL include files.

\item Add the appropriate libraries to the \texttt{symphony} project. For
instance, if you want to use \texttt{\_\_OSI\_CPLEX\_\_}, then add the
\texttt{osiCpxLib} and \texttt{cplex81} library files after deleting 
\texttt{osiClpLib} and \texttt{clpLib} libraries from the
\texttt{symphony} project. If you want to use the native CPLEX interface, 
then delete all the libraries (except the \texttt{symphonyLib}) 
and just add the \texttt{cplex81} library file for it is the unique solver 
library file we need now.

\end{itemize}

\item By default, \BB\ is also set up to use the \texttt{COIN CGL} library for
generating cuts. To use CGL, the \texttt{symphonyLib} project has the
\texttt{ADD\_CGL\_CUTS} preprocessor definition, the path to
\texttt{C:$\backslash$COIN$\backslash$Cgl$\backslash$} (be sure that this path
directs \BB\ to the include subdirectory of CGL). If you don't want to use the 
CGL library, simply
delete the \texttt{ADD\_CGL\_CUTS} preprocessor definition, the CGL path
definitions and the \texttt{cgllib} library from the \texttt{symphony}
project.

\item DO NOT CHANGE COMPILER DEFINES NOT RELATED TO THE LP SOLVER. Important 
note for OSL users: when using OSL in Windows, you must also add 
\texttt{OSLMSDLL} to the list of definitions.

\item Note that there are a number of additional preprocessor definitions that
control the functionality of \BB. These definitions are described in
\texttt{SYMPHONY-5.1/Makefile}, a Unix-style makefile included with the
distribution. To enable the functionality associated with a particular
definition, simply add it to the list of definitions, as above.

\item You must also be sure to have any \texttt{.dll} files required for your
LP solver to be in your search path. Either move the required \texttt{.dll} to
the subdirectory containing \texttt{symphony.exe} or add the path to the 
\texttt{PATH} Windows environment variable.

\item Once you have the proper settings for your LP solver, choose 
\texttt{Build symphony.exe} from the \texttt{Build menu}. This should 
successfully build the \BB\ library and the executable.

\item To test the executable, right click on the \texttt{symphony} project, go
to the \texttt{Debug} tab and set the program arguments to \texttt{-F
..$\backslash${sample.mps}} Note that command-line switches are Unix-style.

\item Now choose \texttt{Execute} from the build menu and the solver
should solve the sample problem.

\end{itemize}

Note that there is some functionality missing from the Windows version. Most
prominently, the timing functions do not work. This functionality
should be easy to add---let me know if you are interested in doing it and I
will give you all the help I can. In addition, the Windows version will only
run in sequential mode for a variety of reasons. However, it should be
relatively easy to get it running in parallel if you can get PVM working under
Windows. Let me know if you are interested.

%\section{Using SYMPHONY}

%\subsection{Using the SYMPHONY executable}

%To use SYMPHONY as a generic solver, type the executable name followed by one
%or more of the command-line switches. There are two required switches. You
%must specify the location of the input file by using ``-F 'filename'.'' This
%input file is assumed to be in MPS format, unless the ``-D'' switch is also
%present, in which case the file will be assumed to be in GMPL model file
%format with the data file specified after the ``-D'' switch. Some of
%SYMPHONY's native parameters can also be set on the command line. Below is a
%list of these parameters. This list can also be obtained by typing the
%executable name with no command-line arguments. Note that all SYMPHONY
%parameters are denoted by a lowercase letter. Note that there are dozens of
%other parameters that can be set with the use of a parameter file. These
%parameters are listed in the SYMPHONY user's manual.

%\subsection{Using the SYMPHONY callable library}

%To use SYMPHONY as a generic callable library, compile SYMPHONY as described
%above. The library that is created along with the solver itself can be linked
%to using the API described Section \ref{callable-library}. As an example of
%using the callable library in this way, see the multi-criteria knapsack
%application (MCKP).

\section{Compiling a Custom Application Using Callbacks}

\subsection{Unix}

First, configure and compile SYMPHONY 5.1 as described in
SYMPHONY-5.1/README-5.1. Modify the variables in the USER/Makefile
appropriately. Typing "make" in the USER subdirectory should successfully make
the USER executable. It will be installed in the directory
SYMPHONY-5.1/USER/bin.$(ARCH)/$(LP\_SOLVER).  After you've successfully
compiled the code, you can develop our custom application by following the
instructions for filling in the user callback functions as described in
Section \ref{SYMPHONY-development}.

\subsection{Microsoft Windows}

First, download \texttt{SYMPHONY-5.1.zip} and unzip the archive. This will
create a subdirectory called \texttt{SYMPHONY-5.1} containing all the source
files together with the \texttt{USER} subdirectory. There are two options to
get the executable. You can either compile on the command-line, using the
MSVC++ makefile,
\texttt{USER$\backslash$WIN32$\backslash$user.mak}, or you can use the 
provided projects and workspaces. However for the second option, it is 
important the \texttt{USER} archive be kept in the \texttt{SYMPHONY-5.1}
subdirectory or the project files will not work. Compiling on the 
command-line is somewhat easier since it requires only editing the makefile 
and typing a single command.

\subsection{Using the NMAKE Utility}

\begin{itemize}
\item 
Edit the \texttt{USER$\backslash$WIN32$\backslash$user.mak} makefile to reflect 
your environment. Only minor edits should be required. An explanation of 
what has to be set is contained in the comments in the makefile. This basically 
requires the same routines that one needs to walk through in 
\texttt{SYMPHONY}'s makefile. See the related parts of \ref{using_nmake} section 
of \texttt{SYMPHONY} above.

\item
Once configuration is done, type \texttt{nmake /f user.mak} in the 
\texttt{USER$\backslash$WIN32} subdirectory. The executable \texttt{user.exe} 
will be created under the \texttt{USER$\backslash$WIN32$\backslash$Debug} 
directory.

\item
To test the executable, type 
\texttt{user.exe -F ..$\backslash$..$\backslash$sample.mps} 
at a command prompt from the \texttt{USER$\backslash$WIN32$\backslash$Debug} 
directory. After this point, you will be ready to develop your own application 
by modifying the other files in the \texttt{USER} subdirectory.
\end{itemize}

\subsection{Using the MSVC++ Workspace}

\begin{itemize}
\item
In MS Visual C++ 6.0, open the workspace 
\texttt{SYMPHONY-5.1$\backslash$USER$\backslash$WIN32$\backslash$user.dsw}.
Note that there are two projects, one called \texttt{symphonyLib} and the other 
called \texttt{user}.The \texttt{symphonyLib} project compiles the source code, with the 
calls to the user-defined callbacks used to customize the solver, to create 
the callable library: \texttt{symphonyLib.lib}. The \texttt{user} 
project compiles those user callbacks together with the main function, links 
them with the callable library and creates the executable: \texttt{user.exe}.

\item 
The configuration steps are exactly the same with the MSVC++ section of 
\texttt{SYMPHONY}. The only 
difference is that, you have the \texttt{user} project instead of the
\texttt{symphony} project. Go through the related steps of section 
\ref{getting_started_windows} to see how to configure to use 
\texttt{COIN}, \texttt{OSI}, \texttt{CGL}, \texttt{COIN} utilities, 
\texttt{GMPL} input, and to change the lp solver which is by default 
\texttt{CLP}.

\item
Once you have the proper settings for your LP solver, choose \texttt{Build
user.exe} from the \texttt{Build} menu. This should successfully 
build the executable.

\item
To test the executable, right click on the \texttt{user} project, go to the
\texttt{Debug} tab and set the program arguments to 
\texttt{-F ..$\backslash$sample.mps}. Note that command-line switches are 
Unix-style.

\item
Now choose \texttt{Execute} from the build menu and you have a working branch
and bound solver! After successful compilation, you can fill in the user
callback functions as describe in Section{SYMPHONY-development}.
\end{itemize}

\section{Sample Applications}

There are a number of sample applications available as examples of how to do
development with \BB. These include solvers for the matching problem, the set
partitioning problem (simple and advanced versions), the vehicle routing and
traveling salesman problems, the mixed postman problem and, capacitated
network routing problem. These applications are distributed as separate
packages and can be downloaded from
\texttt{\htmladdnormallink{http://www.branchandcut.org/SYMPHONY}{http://www.branchandcut.org/SYMPHONY/}}. There is also a white paper that guides the
user through the development of the matching solver.

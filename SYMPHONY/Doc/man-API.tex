\section{Using SYMPHONY Interactively}

\section{Using the Callable Library}\label{callable_library}

SYMPHONY's callable library consists of a complete set of subroutines for
loading and modifying problem data, setting parameters, and invoking solution
algorithms. The user invokes these subroutines through the API specified in
the header file \texttt{sym\_api.h}. Some of the basic commands are described
below. For the sake of brevity, the arguments have been left out. 

\paragraph{\texttt{sym\_open\_environment()}} Opens a new environment, and
returns a pointer to it. This pointer then has to be passed as an argument to
all other API subroutines (in the C++ interface, this pointer is maintained
for the user).

\paragraph{\texttt{sym\_parse\_command\_line()}} Invokes the built-in
parser for setting commonly used parameters, such as the file name which to
read the problem data, via command-line switches. A call to this subroutine
instructs SYMPHONY to parse the command line and set the appropriate
parameters. This subroutine also sets all other parameter values to their
defaults, so it should only called when this is desired.

\paragraph{\texttt{sym\_load\_problem()}} Reads the problem data and sets up
the root subproblem. This includes specifying which cuts and variables are in
the \emph{core} (those that are initially present in every subproblem during
the search process) and the additional cuts and variables to be initially
active in the root subproblem. By default, SYMPHONY reads an MPS or GMPL
file specified by the user, but the user can override this default by
implementing a user callback that reads the data from a file in a customized
format (see Section \ref{callback}).

\paragraph{\texttt{sym\_find\_initial\_bounds()}} Invokes the user callback to
find initial bounds using a custom heuristic.

\paragraph{\texttt{sym\_solve()}} Solves the currently loaded problem from
scratch. This method is described in more detail in Section 
\ref{initial_solve}.

\paragraph{\texttt{sym\_warm\_solve()}} Solves the currently loaded problem 
from a warm start. This method is described in more detail in 
Section \ref{warm_solve}.\\

\paragraph{\texttt{sym\_mc\_solve()}} Solves the currently loaded problem as a
multicriteria problem. This method is described in more detail in Section 
\ref{mc_solve}.

\paragraph{\texttt{sym\_close\_environment()}} Frees all problem data and
deletes the environment. \\

\noindent As an example of the use of the library functions, Figure
\ref{default_main} shows the code for implementing a generic MILP solver with
default parameter settings.
\begin{figure}[tb]
%\centering
\begin{Verbatim}[frame=lines]
int main(int argc, char **argv)
{
   sym_environment *env = sym_open_environment();
   sym_parse_command_line(env, argc, argv);
   sym_load_problem(env);
   sym_solve(env);
   sym_close_environment(env);
}
\end{Verbatim}
\caption{Implementation of a generic MILP solver with the SYMPHONY
C callable library. \label{default_main}}
\end{figure}
To read in an MPS file called \texttt{sample.mps} and solve it using 
this program, the following command would be issued: \\
\begin{verbatim}
symphony -F sample.mps
\end{verbatim}
The user does not have to invoke a command to read the MPS file. During the
call to \texttt{sym\_parse\_command\_line()}, SYMPHONY determines that the
user wants to read in an MPS file. During the subsequent call to
\texttt{sym\_load\_problem()}, the file is read and the problem data stored.
To read an GMPL file, the user would issue the command
\begin{verbatim}
symphony -F sample.mod -D sample.dat
\end{verbatim}
Although the same command-line switch is used to specify the model file, the
additional presence of the \texttt{-D} option indicates to SYMPHONY that the
model file is in GMPL format and GLPK's GMPL parser is invoked
\cite{GLPK}. Note that the interface and the code of Figure \ref{default_main}
is the same for both sequential and parallel computations. The choice between
sequential and parallel execution modes is made at compile-time through
modification of the makefile or the project settings, depending on the
operating system.

To start the solution process from a warm start, the \texttt{sym\_warm\_solve()}
command is used. SYMPHONY automatically records the warm start information
resulting from the last solve call and restarts from that checkpoint if a call
to \texttt{sym\_warm\_solve()} is made. Alternatively, external warm start
information can be loaded manually. Figure \ref{dynamic} illustrates the use
of the re-solve capability by showing the code for implementing a solver that
changes from depth first search to best first search after the first feasible
solution is found.
\begin{figure}[tb]
%\centering
\begin{Verbatim}[frame=lines]
int main(int argc, char **argv)
{
   sym_environment *env = sym_open_environment();
   sym_parse_command_line(env, argc, argv);
   sym_load_problem(env);
   sym_set_int_param(env, "find_first_feasible", TRUE);
   sym_set_int_param(env, "node_selection_strategy", DEPTH_FIRST_SEARCH);
   sym_solve(env);
   sym_set_int_param(env, "find_first_feasible", FALSE);
   sym_set_int_param(env, "node_selection_strategy", BEST_FIRST_SEARCH);
   sym_warm_solve(env);
}
\end{Verbatim}
\caption{Implementation of a dynamic MILP solver with SYMPHONY. 
\label{dynamic}}
\end{figure}
The user can also modify problem data in between calls to the solver. Code for
doing so is shown in Figure \ref{warm_start}. In this example, the
solver is allowed to process 100 nodes and then save the warm start
information. Afterward, the original problem is solved to optimality, then is
modified and re-solved from the saved checkpoint. 
\begin{figure}[tb]
%\centering
\begin{Verbatim}[frame=lines]
int main(int argc, char **argv)
{
   warm_start_desc *ws;
   sym_environment *env = sym_open_environment();
   sym_parse_command_line(env, argc, argv);
   sym_load_problem(env);
   sym_set_int_param(env, "node_limit", 100);
   sym_set_int_param(env, "keep_warm_start", TRUE);
   sym_solve(env);
   ws = sym_get_warm_start(env);
   sym_set_int_param(env, "node_limit", -1);
   sym_warm_solve(env);
   sym_set_obj_coeff(env, 0, 100);
   sym_set_obj_coeff(env, 200, 150);
   sym_set_warm_start(ws);
   sym_warm_solve(env);
}
\end{Verbatim}
\caption{Use of SYMPHONY's warm start capability. \label{warm_start}}
\end{figure}

Finally, SYMPHONY now also has a bicriteria solve call. The applications of
such a solver are numerous. Besides yielding the ability to closely examine
the tradeoffs between competing objectives, the method can be used to perform
detailed sensitivity analysis in a manner analogous to that which can be done
with simplex based solvers for linear programs. As an example, suppose we
would like to know exactly how the optimal objective function value for a
given pure integer program depends on the value of a given objective function
coefficient. Consider increasing the objective function
coefficient of variable $i$ from its current value. Taking the first objective
function to be the original one and taking the second objective function to be
the $i^\textrm{th}$ unit vector, we can derive the desired sensitivity
function by using the bicriteria solution algorithm to enumerate all supported
solutions and breakpoints. This information can easily be used to obtain the
desired function. Figure \ref{multi_criteria} shows the code for performing
this analysis on variable 0. 
\begin{figure}[tb]
%\centering
\begin{Verbatim}[frame=lines]
int main(int argc, char **argv)
{
   sym_environment *env = sym_open_environment();
   sym_parse_command_line(env, argc, argv);
   sym_load_problem(env);
   syn_set_obj2_coeff(env, 0, 1);
   sym_mc_solve(env);
}
\end{Verbatim}
\caption{Performing sensitivity analysis with SYMPHONY's bicriteria solver.
\label{multi_criteria}}
\end{figure}

In addition to the parts of the API we have just described, there are a number
of standard subroutines for accessing and modifying problem data and
parameters. These can be used between calls to the solver to change the
behavior of the algorithm or to modify the instance being solved. These
modifications are discussed in more detail in Section \ref{warm_solve}.

\section{Using the OSI Interface}\label{OSI}

The Open Solver Interface (OSI) is a C++ class that provides a standard API
for accessing a variety of solvers for mathematical programs. It is provided
as part of the COIN-OR repository \cite{coin-or}, along with a collection of
solver-specific derived classes that translate OSI call into calls to the
underlying libraries of the solvers. A code implemented using calls to the
methods in the OSI base class can easily be linked with any solver for which
there is an OSI interface. This allows development of solver-independent codes
and eliminates many portability issues. The current incarnation of OSI
supports only solvers for linear and mixed-integer linear programs, although a
new version supporting a wider variety of solvers is currently under
development.

We have implemented an OSI interface for SYMPHONY 5.1 that allows any solver
built with SYMPHONY to be accessed through the OSI, including customized
solvers and those configured to run on parallel architectures. To ease code
maintenance, for each method in the OSI base class, there is a corresponding
method in the callable library. The OSI methods are implemented simply as
wrapped calls to the SYMPHONY callable library. When an instance of the OSI
interface class is constructed, a call is made to
\texttt{sym\_open\_environment()} and a pointer to the environment is stored
in the class. Most subsequent calls within the class can then be made without
any arguments. When the OSI object is destroyed,
\texttt{sym\_close\_environment} is called and the environment is destroyed.

To fully support SYMPHONY's capabilities, we have extended the OSI interface to
include some methods not in the base class. For example, we added calls
equivalent to our \texttt{sym\_parse\_command\_line()} and
\texttt{sym\_find\_initial\_bounds()}. Figure \ref{OSI_main} shows the
program of Figure \ref{default_main} implemented using the OSI interface.
\begin{figure}[tb]
\begin{Verbatim}[frame=lines]
int main(int argc, char **argv)
{
   OsiSymSolverInterface si;
   si.parseCommandLine(argc, argv);
   si.loadProblem();
   si.branchAndBound();
}
\end{Verbatim}
\caption{Implementation of a generic MILP solver with the SYMPHONY
OSI interface. \label{OSI_main}}
\end{figure}
Note that the code would be exactly the same for accessing any customized
SYMPHONY solver, sequential or parallel.

Although we are using the OSI to access a MILP solver, the current version of
the OSI is geared primarily toward support of solvers for linear programming
(LP) problems. This is because LP solvers employing some version of the
simplex algorithm support much richer functionality and a wider range of
interface functions, due to their support of warm starting from previously
saved checkpoints. This functionality is difficult to provide for MILP
solvers.  In SYMPHONY 5.1, we have implemented for MILPs some of the same
functionality that has long been available for LP solvers. As such, our OSI
interface supports warm starting and sensitivity analysis. The implementations
of this functionality is straightforward at the moment, but will be improved
in future versions.

\section{Using Callback Functions}\label{callback}

The user's main avenues for customization of SYMPHONY are the tuning of
parameters and the implementation of one or more of over 50 user callback
functions. The callback functions allow the user to override SYMPHONY's
default behavior for many of the functions performed as part of its algorithm.
The user has complete control over branching, cutting plane generation,
management of the cut pool and the LP relaxation, search and diving
strategies, and limited column generation. The callback functions are grouped
by module according to their functionality. The names of the callback
functions begin with the prefix \texttt{user\_}. For instance, the
\texttt{user\_find\_cuts()} subroutine is used to implement subroutines for
finding problem-specific cutting planes and is part of the cut generation
module. A full list of callbacks is contained in Chapter \ref{API}.

Callbacks in SYMPHONY are implemented slightly differently than in other
popular libraries. Each user function is called from a SYMPHONY \emph{wrapper
function} that interprets the user's return value and determines what action
should be taken. If the user performs the required function, the wrapper
function normally exits without further action. If the user requests that
SYMPHONY perform a certain default action, then this is done. Files containing
default function stubs for all callbacks are provided along with the SYMPHONY
source code and must be compiled and linked with SYMPHONY's internal library
functions to obtain an executable. Makefiles and Microsoft Visual C++ project
files are provided for automatic compilation.

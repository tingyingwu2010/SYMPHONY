BB\ (Single- or Multi-Process Optimization over Networks) Version 4.0 is a
powerful environment for implementing custom branch, cut, and price
algorithms. The subroutines in the \BB\ library comprise a state-of-the-art
MILP solver designed to be modular and easy to customize for various problem
settings. All internal library subroutines are generic---their implementation
does not depend on the the problem-setting. As of Version 4.0, SYMPHONY works
out of the box as a generic MILP solver, with the capability to read both MPS
files and GMPL (a subset of AMPL) files and solve the described mixed integer
programs. To customize SYMPHONY, various user subroutines can be written and
parameters set that modify the default behavior of the algorithm. The API for
these subroutines is described in this manual and files containing function
stubs are provided. As an example, by modifying the default I/O subroutine,
one can easily modify the solver so that it reads in problem instances in a
custom format (such as the TSPLIB format for specifying traveling salesman
problem instances).

The vast majority of the computation takes place within a ``black box,'' of
which the user need have no knowledge. \BB\ performs all the normal functions
of branch and cut---tree management, LP solution, cut pool management, as well
as inter-process or inter-thread communication. \BB\ can be built in a variety
of configurations, ranging from fully parallel to completely sequential,
depending on the user's needs. The library runs serially on almost any
platform, and can also run in parallel in either a fully distributed
environment (network of workstations) or shared-memory environment simply by
changing a few options in the makefile. To run in a distributed environment,
the user must have installed {\em
\htmladdnormallink{Parallel Virtual Machine}{http://www.ccs.ornl.gov/pvm/}}
(PVM) software, available for free from Oak Ridge National Laboratories
\begin{latexonly}
at {\tt http://www.ccs.ornl.gov/pvm/} 
\end{latexonly}. 
To run in a shared memory environment, the user must have installed an
OpenMP compliant compiler. A cross-platform compiler called {\em
\htmladdnormallink{Omni}{http://pdplab.trc.rwcp.or.jp/Omni}}, which uses 
{\tt cc} or {\tt gcc} as a back end, is available for free download
\begin{latexonly}
at {\tt http://pdplab.trc.rwcp.or.jp/Omni}.
\end{latexonly}.

New in Version 4.0 is the extensive use of the
\emph{\htmladdnormallink{COIN}{http://www.coin-or.org}}
optimization libraries 
\begin{latexonly} 
COIN optimization libraries,
available from \texttt{http://www.coin-or.org} 
\end{latexonly}.
SYMPHONY now uses COIN's OSI to interface with most commonly available LP
solvers. Generic cuts are now generated using COIN's Cut Generator Library
(CGL) and the COIN LP Solver (CLP) can be used through the OSI to solve the LP
relaxations. The COIN MPS reader is used to read in MILP instances in MPS
format. For a summary of what else is new, see Section \ref{whats-new}. The
improvements have required a number of changes to the API. Code written for
previous versions of SYMPHONY will be broken, but not too badly. Instructions
for porting from previous version are contained in the file
\texttt{SYMPHONY-4.0/README-4.0}.

This section of the manual is concerned with the detailed
specifications needed to develop an application using \BB. It is
assumed that the user has already read the first part of the manual, which
provides a high-level introduction to parallel branch, cut, and price
and the overall design and use of \BB. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Compiling the Sample Application with Unix Operating Systems}
\label{getting_started_unix}

Here is a sketch outline of how to get started with SYMPHONY in Unix. This is
basically the same information contained in the README file that comes with
the distribution and will lead you through the steps required to compile
SYMPHONY as a generic MILP solver that can then be customized by filling out
the functions provided in the user interface files. Because SYMPHONY is
intended to run over nonhomogeneous networks of workstations, installation is
not fully automated, but requires the user to make minor edits to the
Makefile.  With this setup, compilation for multiple architectures and
configurations can be performed in a single directory without reconfiguring or
``cleaning.'' This is convenient on nonhomogeneous networks, but it means that
you might need to edit the Makefiles to get SYMPHONY to compile. For the casual
user, this editing is limited to providing some path names.

\subsubsection{Preparing for Sample Compilation.}

\begin{itemize}

        \item Download the file {\tt SYMPHONY-4.0.tgz}.

        \item Unpack the distribution with {\tt tar -xzf
        SYMPHONY-4.0.tgz}. This will create a subdirectory called
        {\tt SYMPHONY-4.0/} containing the distribution.
        
        \item Edit the makefile ({\tt SYMPHONY-4.0/Makefile}) to reflect your
              environment. This involves specifying the LP solver to be used
              and the paths to various libraries and include files. Only minor
              edits should be required. An explanation of what has to be set
              is contained in the comments in the Makefile. 

        \item To use many of the new capabilities of SYMPHONY, you must have
	      installed the
	      \htmladdnormallink{COIN}{http://www.coin-or.org/}
	      optimization libraries \begin{latexonly} COIN optimization
	      libraries, available from \texttt{http://www.coin-or.org}
	      \end{latexonly}.  Specifically, you should install OSI, CGL, and
	      the Coin utilities (in the \texttt{COIN/Coin directory}). If you
	      want to use the COIN LP solver, you should also download CLP.
	      The path to the COIN libraries must be specified in
	      \texttt{SYMPHONY-4.0/Makefile}.

        \item If you wish to read GMPL/AMPL files, you will have to install
	      the Gnu Linear Programming Kit (GLPK), which contains a parser
	      for GMPL/AMPL files. The path to the GLPK libraries must be
	      specified in \texttt{SYMPHONY-4.0/Makefile}.

\end{itemize}
        
\subsubsection{Compiling the Sequential Version.}

\begin{itemize}
        \item Change to the \texttt{SYMPHONY-4.0/USER} directory and type
\texttt{ make}. This will first make the
\BB\ library (sequential version). After making the \BB\ library, make will
compile the user customization library and link the executable. The name of
the executable is specified in the file \texttt{SYMPHONY-4.0/USER/Makefile}
and is \texttt{mip} by default. The executable is installed in the directory
\texttt{SYMPHONY-4.0/USER/bin.\$(ARCH)/\$(LP\_SOLVER)}, where \texttt{ARCH} is 
the current architecture and \texttt{LP\_SOLVER} is the current LP solver, as 
specified in the makefile. The makefile must be modified to enable parallel 
execution of the code (see below).

\item After the SYMPHONY library is compiled, you are free to type {\tt make
        clean} if you want to save disk space. You should only have to
        remake the library if you change something in \BB's internal files. To
        clean the user files, type {\tt make clean\_user}.

\item To test SYMPHONY, a sample MPS file called \texttt{sample.mps} is included 
with the distribution. To specify the file name, use the \texttt{-F} command-line
option, i.e., type \texttt{bin.$(ARCH)/$(LP\_SOLVER)/mip -F sample.mps} in the
\texttt{SYMPHONY-4.0/USER} directory. To obtain more MPS data files for further
testing, download the MIPLIB library.

\item That's it! Now you are ready to develop your own application by modifying
the files in the \texttt{SYMPHONY-4.0/USER} directory and it's
subdirectories. See the user manual for help.

\end{itemize}

\subsubsection{Compiling the Shared Memory Version.}

PLEASE NOTE THAT THE SHARED MEMORY PARALLEL VERSION HAS NOT BEEN TESTED
IN VERSION 4.0 AND MAY BE BROKEN. PLEASE LET ME KNOW IF YOU WANT TO USE IT AND
I WILL GET IT WORKING.

\begin{itemize}
        \item To compile a shared memory version, obtain an OpenMP
        compliant compiler, such as \htmladdnormallink{Omni}
        {http://phase.etl.go.jp/Omni/}
\begin{latexonly} 
        (free from {\tt http://phase.etl.go.jp/Omni})
\end{latexonly}. 
        Other options are listed at \htmladdnormallink{the OpenMP Web
        site}{http://www.openmp.org}
\begin{latexonly}
        ({\tt http://www.openmp.org})
\end{latexonly}.

        \item Follow the instructions above for configuring the makefile. Set
the variable {\tt CC} to the compiler name in the makefile and compile as
above. Note that if you have previously compiled the sequential version, then
you should first type {\tt make clean\_all}, as this version uses the same
directories.  With one thread allowed, it should run exactly the same as the
sequential version so there is no need to compile both versions.

        \item Voila, you have a shared memory parallel solver. As above, to
test SYMPHONY, a sample MPS file called \texttt{sample.mps} is included with the
distribution. To specify the file name, use the \texttt{-F} command-line option,
i.e., type \texttt{bin.$(ARCH)/$(LP\_SOLVER)/mip -F sample.mps} in the
\texttt{SYMPHONY-4.0/USER} directory. To obtain more MPS data files for further
testing, download the MIPLIB library.

\item That's it! Now you are ready to develop your own application by modifying
the files in the \texttt{SYMPHONY-4.0/USER} directory and it's
subdirectories. See the user manual for help.

\end{itemize}

\subsubsection{Compiling the Distributed Version.}

PLEASE NOTE THAT THE DISTRIBUTED MEMORY PARALLEL VERSION HAS NOT BEEN TESTED
INVERSION 4.0 AND MAY BE BROKEN. PLEASE LET ME KNOW IF YOU WANT TO USE IT AND
I WILL GET IT WORKING.

\begin{itemize}
        \item If you wish to compile a distributed version of the code, obtain
and install the {\em \htmladdnormallink{Parallel Virtual
Machine}{http://www.csm.ornl.gov/pvm/}} (PVM) software, available for free
from Oak Ridge National Laboratories
\begin{latexonly}
        at {\tt http://www.ccs.ornl.gov/pvm/}
\end{latexonly}. 
        See Section \ref{PVM} for more notes on using PVM.
        
        \item In \texttt{SYMPHONY-4.0/Makefile}, be sure to set the {\tt
        COMM\_PROTOCOL} variable to {\tt PVM}. Also, in
        \texttt{SYMPHONY-4.0/USER/Makefile}, change one or more of {\tt
        COMPILE\_IN\_TM}, {\tt COMPILE\_IN\_LP}, {\tt COMPILE\_IN\_CG}, and
        {\tt COMPILE\_IN\_CP}, to {\tt FALSE}, or you will end up with the
        sequential version. Various combinations of these variables will give
        you different configurations and different executables. See Section
        \ref{configuration} for more info on setting them. Also, be sure to
        set the path variables in the makefile appropriately so that make can
        find the PVM library.

        \item Type {\tt make} in the \texttt{SYMPHPONY-4.0/USER} directory to
        make the distributed libraries. As in Step 1 of the sequential
        version, you may type {\tt make clean} after making the
        library. It should not have to remade again unless you modify
        \BB's internal files.

        \item After the \BB\ libraries, user code will be compiled and
        required executables linked.

        \item Make sure there are links from your
        \texttt{\$PVM\_ROOT/bin/\$PVM\_ARCH/} directory to each of the
        executables in the
        \texttt{SYMPHONY-4.0/USER/bin.\$(ARCH)/\$(LP\_SOLVER)} directory. 
	This is required by PVM.

        \item Start the PVM daemon by typing {\tt pvm} on the command line
        and then typing {\tt quit}.

        \item As above, test SYMPHONY using the sample MPS file called
        \texttt{sample.mps} is included with the distribution. To specify the
        file name, use the \texttt{-F} command-line option, i.e., type
        \texttt{bin.$(ARCH)/$(LP\_SOLVER)/mip -F sample.mps} in the
        \texttt{SYMPHONY-4.0/USER} directory. To obtain more MPS data files
        for further testing, download the MIPLIB library.

\end{itemize}

\noindent This should result in the successful compilation of the sample
application. Once you have accomplished this much, you are well on
your way to having an application of your own. Don't be daunted by the
seemingly endless list of user function that you are about to
encounter. Most of them are optional or have default options. If you
get lost, consult the source code for the sample application to see
how it's done.

\subsection{Compiling the Sample Application with Microsoft Windows}
\label{getting_started_windows}

Here is a sketch outline of how to compile SYMPHONY in Microsoft Windows. For
information on developing your own applications, please see the quick start
guide below or the detailed explanation in the user's manual. Direct support
is provided for compilation under MS Visual Studio 6.0. Compilation for other
compilers should also be possible. Note that the Windows version has some
limitations. Detailed timing information is not currently provided.  Support
is only provided for running in sequential mode at this time.

First, download \texttt{SYMPHONY-4.0.zip} and unzip the archive. This will
create a subdirectory called \texttt{SYMPHONY-4.0$\backslash$} containing all
the source files. You now have two options. You can either compile on the
command-line, using the MSVC++ makefile 
\texttt{SYMPHONY-4.0$\backslash$WIN32$\backslash$user.mak} or you
can use the provided projects and workspaces. Compiling on the command-line is
somewhat easier since it requires only editing the makefile and typing a
single command.

\underbar{Using the NMAKE Utility}:

\begin{itemize}

\item Edit the file
\texttt{SYMPHONY-4.0$\backslash$USER$\backslash$WIN32$\backslash$user.mak} to
reflect your environment. This involves specifying the LP solver to be used
and various paths. Only minor edits should be required. An explanation of what
has to be set is contained in the comments in the Makefile.

\item To use many of the new capabilities of SYMPHONY, you must have installed
the \emph{\htmladdnormallink{COIN}{http://www.ccs.ornl.gov/pvm/}} optimization
libraries 
\begin{latexonly} 
COIN optimization libraries, available from
\texttt{http://www.coin-or.org} 
\end{latexonly}. Specifically, you should
install OSI, CGL, and the Coin utilities (in the COIN/Coin directory). If you
want to use the COIN LP solver, you should also download CLP. The path to the
COIN libraries must be specified in
\texttt{SYMPHONY-4.0$\backslash$USER$\backslash$WIN32$\backslash$user.mak}.

\item If you wish to read GMPL/AMPL files, you will have to install the Gnu
Linear Programming Kit (GLPK), which contains a parser for GMPL/AMPL
files. The path to the GLPK libraries must be specified in
\texttt{SYMPHONY-4.0$\backslash$USER$\backslash$WIN32$\backslash$user.mak}.

\item Once configuration is done, type \texttt{nmake /f user.mak} at the
command prompt in the
\texttt{SYMPHONY-4.0$\backslash$USER$\backslash$WIN32 directory}. The
executable \texttt{symphony.exe} will be created in the
\texttt{SYMPHONY-4.0$\backslash$USER$\backslash$WIN32$\backslash$Debug}  
directory.

\item To test the executable, type \texttt{symphony.exe -F ..$\backslash$..$\backslash$test.mps} at a command 
prompt in the
\texttt{SYMPHONY-4.0$\backslash$USER$\backslash$WIN32$\backslash$Debug} 
directory.

\end{itemize}

\underbar{Using the MSVC++ Workspace}:

\begin{itemize}

\item In MS Visual C++ 6.0, open the workspace
\texttt{SYMPHONY-4.0$\backslash$USER$\backslash$WIN32$\backslash$user.dsw}. 
Note that there are two projects, one called \texttt{symphony} and one called
\texttt{user}.  The \texttt{symphony} project compiles the source of the internal
library. The \texttt{user} project compiles a separate library containing the
user-defined functions that can be used to customize the solver.

\item To use many of the new capabilities of SYMPHONY, you must have installed
the \emph{\htmladdnormallink{COIN}{http://www.ccs.ornl.gov/pvm/}} optimization
libraries 
\begin{latexonly} 
COIN optimization libraries, available from
\texttt{http://www.coin-or.org} 
\end{latexonly}. Specifically, you should
install OSI, CGL, and the Coin utilities (in the COIN/Coin directory). If you
want to use the COIN LP solver, you should also download CLP. The default
location for COIN is C:$backslash$COIN$backslash$.

\item By default, SYMPHONY is set up to use the OSI CPLEX interface. To see this
check the following settings:

\begin{itemize}

\item \texttt{\_\_OSI\_CPLEX\_\_} is defined in the preprocessor definitions
of both \texttt{symphony} and \texttt{user} projects (to see that, right-click
on one of the projects, and then choose \texttt{Settings --> C/C++ -->
Preprocessor} in the category drop-down menu).

\item Paths to the include files of COIN utilities (Coin), OSI, OSI\_CPLEX, and
CPLEX are specified in the same settings window as for the preprocessor
definitions. Note that the Coin, OSI, and OSI\_CPLEX include directories are
assumed to be in \texttt{C:$\backslash$COIN$\backslash$Coin},
\texttt{C:$\backslash$COIN$\backslash$Osi},
\texttt{C:$\backslash$COIN$\backslash$Osi$\backslash$OsiCpx} and 
\texttt{C:$\backslash$ILOG$\backslash$cplex81$\backslash$include$\backslash$ilcplex}
directories, respectively. If they are not, make sure that you have set the
correct paths in both projects before compiling.

\item The \texttt{symphony} project is dependent on the \texttt{user} project
(see the dependencies in Project --> Dependencies) and it includes the
necessary libraries: \texttt{user}, \texttt{osiCpxLib}, \texttt{osiLib},
\texttt{coinLib} and \texttt{cplex81} (solver library).

\end{itemize}

If you want to use the native CPLEX interface (without downloading COIN) or a
solver other than CPLEX:

\begin{itemize}

\item If you want to use another OSI interface, change the preprocessor
definition from \texttt{\_\_OSI\_CPLEX\_\_} to \texttt{\_\_OSI\_XXX\_\_}
(\texttt{\_\_OSI\_CLP\_\_}, \texttt{\_\_OSI\_GLPK\_\_}, \texttt{\_\_OSI\_OSL\_\_},
etc.). Otherwise, change it to \texttt{\_\_XXX\_\_} (you have two options:
\texttt{\_\_CPLEX\_\_} and \texttt{\_\_OSL\_\_}) in both projects.

\item Change the path definitions of the include files: for instance, if you want
to use \texttt{\_\_OSI\_OSL\_\_}, define
\texttt{C:$\backslash$COIN$\backslash$Osi$\backslash$OsiOsl} and \texttt{C:$\backslash$Program
Files$\backslash$IbmOslV3Lib$\backslash$osllib} (assuming it is installed
there) instead of OsiCpx and CPLEX path definitions. If you want to use the
native OSL interface, delete all the path definitions (you are not required to
have COIN or OSI), and just add the path definition for the OSL include files.

\item Add the appropriate libraries to the \texttt{symphony} project. For
instance, if you want to use \texttt{\_\_OSI\_OSL\_\_} then add the
\texttt{osiOslLib} and \texttt{oslmd6030} (OSL solver lib file) library files
after deleting \texttt{osiCpxLib} and \texttt{cplex81} libraries from the
\texttt{symphony} project (you can do that by right-clicking on the
\texttt{symphony} project and then choosing --> Add files to project with
\texttt{library files} selected as the file type). If 
you want to use the native OSL interface, then delete all the libraries
(except the \texttt{user} library ) from the \texttt{symphony} project and
just add the \texttt{oslmd6030} library file for it is the unique solver
library file we need now.

\end{itemize}

\item By default, SYMPHONY is also set up to use the COIN CGL library for
generating cuts. To use CGL, the \texttt{symphony} project has the
\texttt{ADD\_CGL\_CUTS} preprocessor definition, the path to
\texttt{C:$\backslash$COIN$\backslash$Cgl$\backslash$} (be sure that this path
directs SYMPHONY to the include directory of CGL) and a dependence on the
\texttt{cgllib} library. If you also don't want to use the CGL library, simply
delete the \texttt{ADD\_CGL\_CUTS} preprocessor definition, the CGL path
definitions and the \texttt{cgllib} library from the \texttt{symphony}
project.

\item DO NOT CHANGE COMPILER DEFINES NOT RELATED TO THE LP SOLVER. Important note
for OSL users: When using OSL in Windows, you must also add \texttt{OSLMSDLL}
to the list of definitions.

\item Note that there are a number of additional preprocessor definitions that
control the functionality of SYMPHONY. These definitions are described in
\texttt{SYMPHONY-4.0/Makefile}, a Unix-style makefile included with the
distribution. To enable the functionality associated with a particular
definition, simply add it to the list of definitions, as above.

\item You must also be sure to have any \texttt{.dll} files required for your
LP solver to be in your search path. Either move the required \texttt{.dll} to
the directory containing symphony.exe or add the path to the \texttt{PATH}
Windows environment variable.

\item Once you have the proper settings for your LP solver, choose \texttt{Build
symphony.exe} from the \texttt{Build menu}. This should successfully build
the executable.

\item To test the executable, right click on the \texttt{symphony} project, go
to the \texttt{Debug} tab and set the program arguments to \texttt{-F
test.mps} Note that command-line switches are Unix-style.

\item Now choose \texttt{Execute} from the build menu and the solver
should solve the sample problem.

\end{itemize}

Note that there is some functionality missing from the Windows version. Most
prominently, the timing functions do not work. I suppose this functionality
should be easy to add -- let me know if you are interested in doing it and I
will give you all the help I can. In addition, the Windows version will only
run in sequential mode for a variety of reasons. However, it should be
relatively easy to get it running in parallel if you can get PVM working under
Windows. Let me know if you are interested.

\subsection{Customizing SYMPHONY}

\subsubsection{Unix}

Developing a simple branch and bound solver that can read in instance data in
a custom format is straightforward using the template provided in the
\texttt{SYMPHONY-4.0/USER/} directory. The simplest approach is to develop a 
sequential application, sharing a single user data structure among all the
modules. Using this approach, an application can be developed by filling in
only a few simple functions. Here are four steps to make the most common
custom modifications.

\begin{enumerate}

\item Decide what run-time parameters you might need and what data has 
to be stored to describe your instance. Edit the file
\texttt{SYMPHONY-4.0/USER/include/user.h}, adding the appropriate fields to the
\texttt{user\_parameter} and \texttt{user\_problem} structure to store the
relevant values.

\item Now edit the file \texttt{SYMPHONY-4.0/USER/Master/user\_master.c}. Only two
function needs to be filled out initially in order to read in . The function
\texttt{user\_io()} is where you can read in the instance data, if it is in
something other than MPS format (a TSPLIB file, for example. Note that the
name of the file to read the instance data from can be specified on the
command line using the \texttt{-F} option by default. Also, you'll probably
need to modify the \texttt{user\_initialize\_root\_node()} function to set up
the root node.

\item Edit the file \texttt{USER/LP/user\_lp.c}. The function
\hyperref{{\tt user\_create\_subproblem()}} {{\tt user\_create\_subproblem()} (see
Section }{)}{user_create_subproblem} must be filled out. This is the most
important function, as it sets up the initial LP relaxation in each search
node.

\item You may also want to add some problem-specific cutting planes by modifying
the \texttt{user\_find\_cuts()} function.

\end{enumerate}

Now compile by by typing \texttt{make} (assuming that the make
file has already been modified appropriately). That's it! You should now have
a working branch and bound solver. Next you can work on filling in more
advanced functions and adding cutting planes.

\subsubsection{Microsoft Windows}
Developing a simple branch and bound solver that can read in instance data in
a custom format is straightforward using the template provided in the
\texttt{SYMPHONY-4.0$\backslash$USER$\backslash$} directory. The simplest approach is to develop a
sequential application, sharing a single user data structure among all the
modules. Using this approach, an application can be developed by filling in
only a few simple functions. Here are some steps to make the most common
custom modifications.

\begin{enumerate}

\item Decide what run-time parameters you might need and what data has 
to be stored to describe your instance. Edit the file
\texttt{USER$\backslash$include$\backslash$user.h}, adding the appropriate
fields to the \texttt{user\_parameter} and \texttt{user\_problem} structure to
store the relevant values.

\item Now edit the file
\texttt{USER$\backslash$Master$\backslash$user\_master.c}. Only two
function needs to be filled out initially in order to read in . The function
\texttt{user\_io()} is where you can read in the instance data, if it is in
something other than MPS format (a TSPLIB file, for example. Note that the
name of the file to read the instance data from can be specified on the
command line using the \texttt{-F} option by default. Also, you'll probably
need to modify the \texttt{user\_initialize\_root\_node()} function to set up
the root node.

\item Edit the file \texttt{USER$\backslash$LP$\backslash$user\_lp.c}. The
function \hyperref{{\tt user\_create\_subproblem()}} {{\tt
user\_create\_subproblem()} (see Section }{)}{user_create_subproblem} must be
filled out. This is the most important function, as it sets up the initial LP
relaxation in each search node.

\item You may also want to add some problem-specific cutting planes by modifying
the \texttt{user\_find\_cuts()} function.

\end{enumerate}

Now build again and you have a working branch and bound solver! Next you can
work on filling in more advanced functions and adding cutting planes. See the
documentation for more information on this.

\subsection{Sample Applications}

There are now a number of sample applications available as examples of how
to do development with SYMPHONY. These include solvers for the matching
problem, the set partitioning problem (simple and advanced versions), the 
vehicle routing and traveling salesman problems, and the mixed postman
problem. These applications are distributed as separate packages and can be
downloaded 	      
\emph{\htmladdnormallink{here}{http://www.branchandcut.org/SYMPHONY/}}
\begin{latexonly} 
from \texttt{http://www.branchandcut.org/SYMPHONY}
\end{latexonly}. There is also a white paper that guides the
user through the development of the matching solver.

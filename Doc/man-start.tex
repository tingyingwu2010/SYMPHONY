SYMPHONY Version 5.0 is a powerful environment for implementing custom branch,
cut, and price algorithms. The subroutines in the \BB\ library comprise a
state-of-the-art MILP solver designed to be modular and easy to customize for
various problem settings. All internal library subroutines are generic---their
implementation does not depend on the the problem-setting. As from Version 4.0,
SYMPHONY works out of the box as a generic MILP solver, with the capability to
read both MPS files and GMPL (a subset of AMPL) files and solve the described
mixed integer programs. To customize SYMPHONY, various user subroutines can be
written and parameters set that modify the default behavior of the
algorithm. The API for these subroutines is described in this manual and files
containing function stubs are provided. As an example, by replacing the
default I/O subroutine, one can easily modify the solver so that it reads in
problem instances in a custom format (such as the TSPLIB format for specifying
traveling salesman problem instances).

The vast majority of the computation takes place within a ``black box,'' of
which the user need have no knowledge. \BB\ performs all the normal functions
of branch, cut, and price---tree management, LP solution, cut pool management,
as well as inter-process or inter-thread communication. Solvers can be built
in a wide variety of configurations, ranging from fully parallel to completely
sequential, depending on the user's needs. The library runs serially on almost
any platform, and can also run in parallel in either a fully distributed
environment (network of workstations) or shared-memory environment simply by
changing a few options in the makefile. To run in a distributed environment,
the user must have installed the {\em
\htmladdnormallink{Parallel Virtual Machine}{http://www.ccs.ornl.gov/pvm/}}
(PVM), available for free from Oak Ridge National Laboratories.
To run in a shared memory environment, the user must have installed an
OpenMP compliant compiler. A cross-platform compiler called {\em
\htmladdnormallink{Omni}{http://phase.etl.go.jp/Omni/}}, which uses 
{\tt cc} or {\tt gcc} as a back end, is available for free download
\begin{latexonly}
at {\tt http://phase.etl.go.jp/Omni/}
\end{latexonly}. For other options, visit
\texttt{\htmladdnormallink{http://www.openmp.org}{http://www.openmp.org}}.

SYMPHONY-5.0 is now a C callable library with an interface whose look and
feel is similar to other popular solvers, see Sections \ref{C_Interface} and
\ref{C++_Interface} for the library routines. This interface works for
SYMPHONY's built-in generic MILP solver, as well as any customized algorithm 
developed by implementing one or more of SYMPHONY's user callback functions. 
For a summary of what else is new, see Section \ref{whats-new}.Code written for
previous versions of SYMPHONY will be broken, but not too badly. Instructions
for porting from previous version are contained in the file
\texttt{SYMPHONY-5.0/README-5.0}.

This section of the manual is concerned with the detailed
specifications needed to compile the \BB library, to create the generic 
MILP solver and to develop an application using \BB. It is
assumed that the user has already read the first part of the manual, which
provides a high-level introduction to parallel branch, cut, and price
and the overall design and use of \BB. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Compiling the SYMPHONY Library and Executable with Unix 
Operating Systems}

\label{getting_started_unix}

Here is a sketch outline of how to get started with SYMPHONY in Unix. This is
basically the same information contained in the README file that comes with
the distribution and will lead you through the steps required to compile
SYMPHONY as a generic MILP solver that can then be customized by filling out
the functions provided in the user interface files. For more information, see
Section \ref{advanced-compilation}. 

Because SYMPHONY is intended to run over
nonhomogeneous networks of workstations, installation is not fully automated,
but requires the user to make minor edits to the makefile.  With this setup,
compilation for multiple architectures and configurations can be performed in
a single directory without reconfiguring or ``cleaning.'' This is convenient
on nonhomogeneous networks, but it means that you might need to edit the
makefiles to get SYMPHONY to compile. For the casual user, this editing is
limited to providing some path names.

\subsection{Preparing for Sample Compilation.}

\begin{itemize}

        \item Download the file {\tt SYMPHONY-5.0.tgz}.

        \item Unpack the distribution with {\tt tar -xzf
        SYMPHONY-5.0.tgz}. This will create a subdirectory called
        {\tt SYMPHONY-5.0} containing the distribution.
        
        \item Edit the makefile ({\tt SYMPHONY-5.0/Makefile}) to reflect your
              environment. This involves specifying the LP solver to be used,
              assigning some variables and setting the paths to various 
              libraries and include files.Only minor
              edits should be required. An explanation of what has to be set
              is contained in the comments in the makefile. 

        \item To use many of the new capabilities of SYMPHONY, you must have
	      installed the
	      \htmladdnormallink{COIN}{http://www.coin-or.org/}
	      optimization libraries \begin{latexonly} COIN optimization
	      libraries, available from \texttt{http://www.coin-or.org}
	      \end{latexonly}.  By default, SYMPHONY is 
	      set up to use COIN LP solver, CLP, COIN Open Solver Interface, 
	      OSI, and COIN Cut Generation Library, CGL. To keep this 
	      configuration, you should install OSI, CGL, CLP and the Coin 
	      utilities (under \texttt{COIN/Coin}). The path to 
	      the COIN libraries must be specified in 
	      \texttt{SYMPHONY-5.0/Makefile}.  If you want to use the new OSI 
              interface to SYMPHONY, you should be sure to compile it when you 
              are installing the rest of the COIN packages.

        \item If you wish to read \texttt{GMPL/AMPL} files, you will have to 
              install
	      the Gnu Linear Programming Kit (GLPK), which contains a parser
	      for GMPL/AMPL files. The path to the GLPK libraries must also be
	      specified in \texttt{SYMPHONY-5.0/Makefile}.

%\item Note in this version that, \BB\ can be compiled directly from the 
%root directory to give a callable shared or static library and an executable
%to be used as a generic MILP solver. However, if the user callbacks are 
%intended to be used, similar to the older versions, the user should compile 
%and use the \texttt{USER} application which have its source files 
%under \texttt{SYMPHONY-5.0/USER} directory. The same configuration is also set 
%for the \texttt{USER} application. The only difference is that the 
%main \texttt{symphony} executable is not dependent on the user callback 
%functions whereas the user callback functions are used and, by default, set to 
%return default values for the \texttt{USER} application. Thus, altough the 
%default compilation of \texttt{USER} application will behave as a generic 
%MILP solver, the user can develop his/her own application by modifying the 
%files in the \texttt{SYMPHONY-5.0/USER} directory and it's subdirectories. 
%See the \texttt{README} file of \texttt{USER} application under 
%\texttt{SYMPHONY-5.0/USER} directory and the section 
%\ref{development} for more information.

\end{itemize}
        
\subsection{Compiling the Sequential Version.}

\begin{itemize}

      \item Unlike previous version of \BB, to compile \texttt{SYMPHONY 5.0} as 
a generic solver, the user simply has to type \texttt{make} in the 
\texttt{SYMPHONY-5.0} subdirectory. This will 
first make the \BB\ library (sequential version): 
\texttt{SYMPHONY-5.0/lib.\$(ARCH)/\$(LP\_SOLVER)/libsym.so} (or 
\texttt{'libsym.a'} if library type is set to be static) where 
\texttt{ARCH} is the current architecture and \texttt{LP\_SOLVER} is the 
current LP solver, as specified in the makefile. In addition, in order 
to have the flexibility in using different LP solvers, a symbolic link to the 
latest created callable library with the same name (libsym.so or libsym.a) 
will be created in \texttt{SYMPHONY-5.0/lib} subdirectory. This library 
together with the header files in the subdirectory 
\texttt{SYMPHONY-5.0/include} can then be used to call \BB\ from any C code. 
The \texttt{API} for this is described in section \ref{API}.
After compiling the \BB\ library, the default \texttt{main} function will 
be compiled and linked with the the callable library to form an executable
called \texttt{symphony} to be used for solving generic MILP problems 
in \texttt{MPS} or \texttt{GMPL} format. \texttt{FlopC++} can also be used to 
obtain a capability similar to \texttt{ILOG}'s Concert technology for building 
math programming models. The executable is installed in 
\texttt{SYMPHONY-5.0/bin.\$(ARCH)/\$(LP\_SOLVER)} subdirectory. The makefile 
can also be modified to enable parallel execution of the code (see below).


\item After the \BB\ library is compiled, you are free to type {\tt make
        clean} if you want to save disk space. You should only have to
        remake the library if you change something in \BB's internal files. 

\item To test \BB, a sample MPS file called \texttt{sample.mps} is 
included with the distribution. To specify the file name, use the 
\texttt{-F} command-line option, i.e., type 
\texttt{bin.\$(ARCH)/\$(LP\_SOLVER)/symphony -F sample.mps} in the
\texttt{SYMPHONY-5.0} subdirectory. To obtain more MPS data files for further
testing, download the \texttt{MIPLIB} library.

\item That's it! Now you are ready to use \BB\ callable library or 
solve generic MILP problems through the executable.

\end{itemize}

\subsection{Compiling the Shared Memory Version.}

Please note that the shared-memory parallel version has not been tested in
Version 5.0 and may be broken. Please let me know if you want to use it and I
will get it working. 

\begin{itemize}
        \item To compile a shared memory version, obtain an OpenMP
        compliant compiler, such as \htmladdnormallink{Omni}
        {http://phase.etl.go.jp/Omni/}
\begin{latexonly} 
        (free from {\tt http://phase.etl.go.jp/Omni})
\end{latexonly}. 
        Other options are listed at \htmladdnormallink{the OpenMP Web
        site}{http://www.openmp.org}
\begin{latexonly}
        ({\tt http://www.openmp.org})
\end{latexonly}.

        \item Follow the instructions above for configuring the makefile. Set
the variable {\tt CC} to the compiler name in the makefile and compile as
above. Note that if you have previously compiled the sequential version, then
you should first type {\tt  make clean\_all}, as this version uses the same
directories.  With one thread allowed, it should run exactly the same as the
sequential version so there is no need to compile both versions.

        \item Voila, you have a shared memory parallel solver. As above, to
test \BB, a sample MPS file called \texttt{sample.mps} is included with 
the distribution. To specify the file name, use the \texttt{-F} command-line 
option, i.e., type \texttt{bin.\$(ARCH)/\$(LP\_SOLVER)/symphony -F sample.mps}
in the \texttt{SYMPHONY-5.0} subdirectory. To obtain more MPS data files for 
further testing, download the \texttt{MIPLIB} library.

\item That's it! Now, you are ready to develop your own application using 
\BB\ callable library or solve MILP problems using the executable. See the
user manual for help.

\end{itemize}

\subsection{Compiling the Distributed Version.}

Please note that the distributed-memory parallel version has not been tested
in Version 5.0 and may be broken. Please let me know if you want to use it and
I will get it working.

\begin{itemize}
        \item If you wish to compile a distributed version of the code, obtain
and install the {\em \htmladdnormallink{Parallel Virtual
Machine}{http://www.csm.ornl.gov/pvm/}} (PVM) software, available for free
from Oak Ridge National Laboratories
\begin{latexonly}
        at {\tt http://www.ccs.ornl.gov/pvm/}
\end{latexonly}. 
        See Section \ref{PVM} for more notes on using PVM.
        
        \item In \texttt{SYMPHONY-5.0/Makefile}, be sure to set the {\tt
        COMM\_PROTOCOL} to {\tt PVM}. Also, in
        the same makefile, you need to change one or more of {\tt
        SYM\_COMPILE\_IN\_TM}, {\tt SYM\_COMPILE\_IN\_LP}, 
	{\tt SYM\_COMPILE\_IN\_CG}, and
        {\tt SYM\_COMPILE\_IN\_CP} to {\tt FALSE} or you will end up with the
        sequential version. Various combinations of these variables will give
        you different configurations and different executables. See Section
        \ref{configuration} for more info on setting them. Also, be sure to
        set the path variables in the makefile appropriately so that 
	\texttt{make} can find the PVM library.

        \item As above, type {\tt  make} in the \texttt{SYMPHPONY-5.0} 
	subdirectory to
        make the distributed libraries. As in Step 1 of the sequential
        version, you may type {\tt  make clean} after making the
        library. It should not have to remade again unless you modify
        \BB's internal files.

        \item After the \BB\ libraries, main function will be compiled and
        required executables linked.

        \item Make sure there are links from your
        \texttt{\$(PVM\_ROOT)/bin/\$(PVM\_ARCH)} subdirectory to each of the
        executables in the
        \texttt{SYMPHONY-5.0/bin.\$(ARCH)/\$(LP\_SOLVER)} subdirectory. 
	This is required by PVM.

        \item Start the PVM daemon by typing {\tt  pvm} on the command line
        and then typing {\tt  quit}.

        \item As above, test \BB\ using the sample MPS file called
        \texttt{sample.mps} included with the distribution. To specify the
        file name, use the \texttt{-F} command-line option, i.e., type
        \texttt{bin.\$(ARCH)/\$(LP\_SOLVER)/symphony -F sample.mps} in the
        \texttt{SYMPHONY-5.0} subdirectory. To obtain more MPS data files
        for further testing, download the MIPLIB library.

        \item That's it! Now, you are ready to develop your own application 
	using \BB\ callable library or solve MILP problems using the 
	executable.

\end{itemize}

%\noindent This should result in the successful compilation of the sample
%application. Once you have accomplished this much, you are well on
%your way to having an application of your own. Don't be daunted by the
%seemingly endless list of user function that you are about to
%encounter. Most of them are optional or have default options. If you
%get lost, consult the source code for the sample application to see
%how it's done.

\section{Compiling the SYMPHONY Library and Executable with Microsoft Windows}
\label{getting_started_windows}

Here is a sketch outline of how to compile \BB\ in MS Windows. Direct
support is provided for compilation with MS Visual Studio 6.0. Compilation for
other compilers should also be possible. Note that the Windows version has
some limitations. Detailed timing information is not currently provided.
Support is only provided for running in sequential mode at this time.

First, download \texttt{SYMPHONY-5.0.zip} and unzip the archive. This will
create a subdirectory called \texttt{SYMPHONY-5.0} containing all
the source files. You now have two options. You can either compile on the
command-line, using the MSVC++ makefile called
\texttt{sym.mak} in the \texttt{SYMPHONY-5.0$\backslash$WIN32} subdirectory or 
you can use the provided projects and workspaces. Compiling on the command-line 
is somewhat easier since it requires only editing the makefile and typing a
single command.

\subsection{Using the NMAKE Utility}
\label{using_nmake}

\begin{itemize}

\item Edit the file
\texttt{SYMPHONY-5.0$\backslash$WIN32$\backslash$sym.mak} makefile to
reflect your environment. This involves specifying the LP solver to be used
and various paths. Only minor edits should be required. An explanation of what
has to be set is contained in the comments in the makefile.

\item To use many of the new capabilities of \BB, you must have installed
the \emph{\htmladdnormallink{COIN}{http://www.ccs.ornl.gov/pvm/}} optimization
libraries 
\begin{latexonly} 
COIN optimization libraries, available from
\texttt{http://www.coin-or.org} 
\end{latexonly}. By default \BB\ is 
set to use COIN LP solver, \texttt{CLP}, COIN Open Solver Interface, 
\texttt{OSI}, and COIN Cut Generation Library, \texttt{CGL}. To keep this 
configuration, you should install \texttt{OSI}, \texttt{CGL}, \texttt{CLP} 
and additionally, the Coin utilities (under COIN$\backslash$Coin).The path to 
the COIN libraries must be specified in 
\texttt{SYMPHONY-5.0$\backslash$WIN32$\backslash$sym.mak}.

\item If you wish to read \texttt{GMPL/AMPL} files, you will have to install the 
Gnu Linear Programming Kit (GLPK), which contains a parser for GMPL/AMPL
files. The path to the GLPK libraries must be specified in
the makefile.

\item Once configuration is done, type \texttt{nmake /f sym.mak} at the
command prompt in the \\
\texttt{SYMPHONY-5.0$\backslash$WIN32} subdirectory. 
This will first make the \BB\ library (sequential version): 
\texttt{SYMPHONY-5.0$\backslash$WIN32$\backslash$Debug$\backslash$symphonyLib.lib}. This library together with the header files in the subdirectory
(\texttt{SYMPHONY-5.0$\backslash$include}) can then be
be used to call \BB\ from any C code. The \texttt{API} for this is 
described in section \ref{API}.
After compiling the \BB\ library, the default \texttt{main} function will 
be compiled and linked with the the callable library to form an executable
called \texttt{symphony.exe} to be used for solving generic MILP problems 
in \texttt{MPS} or \texttt{GMPL} format. The executable will be created in the
\texttt{SYMPHONY-5.0$\backslash$WIN32$\backslash$Debug} subdirectory.

\item To test the executable, type \texttt{symphony.exe -F 
..$\backslash$..$\backslash$sample.mps} at a command prompt in the
\texttt{SYMPHONY-5.0$\backslash$WIN32$\backslash$Debug} subdirectory.

\end{itemize}

\subsection{Using the MSVC++ Workspace}

\begin{itemize}

\item In MS Visual C++ 6.0, open the workspace
\texttt{SYMPHONY-5.0$\backslash$WIN32$\backslash$symphony.dsw}. 
Note that there are two projects, one called \texttt{symphony} and the other 
called
\texttt{symphonyLib}. The \texttt{symphonyLib} project compiles the source 
code to create the callable library: \texttt{symphonyLib.lib}. The 
\texttt{symphony} project compiles the main  function and links that with the c
allable library to create the executable: \texttt{symphony.exe}. 

\item To use many of the new capabilities of \BB, you must have installed
the \htmladdnormallink{COIN}{http://www.ccs.ornl.gov/pvm/} optimization
libraries 
\begin{latexonly} 
COIN optimization libraries, available from
\texttt{http://www.coin-or.org} 
\end{latexonly}. By default \BB\ is 
set up to use COIN LP solver, \texttt{CLP}, COIN Open Solver Interface, 
\texttt{OSI}, and COIN Cut Generation Library, \texttt{CGL}. To keep this 
configuration, you should install \texttt{OSI}, \texttt{CGL}, \texttt{CLP} 
and additionally, the Coin utilities (under COIN$\backslash$Coin).
The default location for COIN is C:$\backslash$COIN$\backslash$.

\item By default, \BB\ is set up to use the OSI CLP interface. To see this
check the following settings:

\begin{itemize}

\item \texttt{\_\_OSI\_CLP\_\_} is defined in the preprocessor
definitions of both \texttt{symphony} and \texttt{symphonyLib} projects 
(right-click on one of the projects, and then choose \texttt{Settings --> C/C++
--> Preprocessor} in the category drop-down menu).

\item Paths to the include files of COIN utilities (Coin), OSI, OSI\_CLP, and
CLP are specified in the same settings window as for the preprocessor
definitions. Note that the Coin, OSI, and OSI\_CLP and CLP include 
directories are assumed to be in \texttt{C:$\backslash$COIN$\backslash$Coin},
\texttt{C:$\backslash$COIN$\backslash$Osi},
\texttt{C:$\backslash$COIN$\backslash$Osi$\backslash$OsiClp} and 
\texttt{C:$\backslash$COIN$\backslash$Clp},
directories, respectively. If they are not, make sure that you have set the
correct paths in both projects before compiling.

\item The \texttt{symphony} project is dependent on the \texttt{symphonyLib} 
project (see the dependencies in \texttt{Project --> Dependencies}) 
and it includes the necessary libraries: \texttt{symphonyLib}, 
\texttt{coinLib}, \texttt{osiLib}, \texttt{osiClpLib} and \texttt{clpLib} 
(solver library).

\end{itemize}

If you want to use the native CPLEX or OSL interface 
(without downloading COIN) or a solver other than CLP:

\begin{itemize}

\item If another OSI interface, change the preprocessor
definition in both projects from \texttt{\_\_OSI\_CLP\_\_} to 
\texttt{\_\_OSI\_XXX\_\_} ,
where \texttt{XXX} is replaced by the desired solver's acronym (e.g.,
\texttt{\_\_OSI\_CPLEX\_\_}, \texttt{\_\_OSI\_GLPK\_\_},
\texttt{\_\_OSI\_OSL\_\_}, etc.). Otherwise, change it to either
\texttt{\_\_CPLEX\_\_} or \texttt{\_\_OSL\_\_} in both projects.

\item Change the path definitions of the include files: for instance, if you 
want to use \texttt{\_\_OSI\_CPLEX\_\_}, define
\texttt{C:$\backslash$COIN$\backslash$Osi$\backslash$OsiCpx} and 
\texttt{C:$\backslash$ILOG$\backslash$cplex81$\backslash$include$\backslash$ilcplex} 
(assuming it is installed there) instead of the OSI CLP and CLP path 
definitions. Or, if you want to use \texttt{\_\_OSI\_OSL\_\_}, define 
\texttt{C:$\backslash$COIN$\backslash$Osi$\backslash$OsiOsl} and 
\texttt{C:$\backslash$ProgramFiles$\backslash$IbmOslV3Lib$\backslash$osllib}
(assuming OSL is installed there) instead of the OSI CLP and CLP path 
definitions. If you want to use the native CPLEX or OSL interface, 
delete all the path  definitions (you are not required to have COIN or OSI), 
and just add the path definitions for the CPLEX or OSL include files.

\item Add the appropriate libraries to the \texttt{symphony} project. For
instance, if you want to use \texttt{\_\_OSI\_CPLEX\_\_}, then add the
\texttt{osiCpxLib} and \texttt{cplex81} library files after deleting 
\texttt{osiClpLib} and \texttt{clpLib} libraries from the
\texttt{symphony} project. If you want to use the native CPLEX interface, 
then delete all the libraries (except the \texttt{symphonyLib}) 
and just add the \texttt{cplex81} library file for it is the unique solver 
library file we need now.

\end{itemize}

\item By default, \BB\ is also set up to use the \texttt{COIN CGL} library for
generating cuts. To use CGL, the \texttt{symphonyLib} project has the
\texttt{ADD\_CGL\_CUTS} preprocessor definition, the path to
\texttt{C:$\backslash$COIN$\backslash$Cgl$\backslash$} (be sure that this path
directs \BB\ to the include subdirectory of CGL). If you don't want to use the 
CGL library, simply
delete the \texttt{ADD\_CGL\_CUTS} preprocessor definition, the CGL path
definitions and the \texttt{cgllib} library from the \texttt{symphony}
project.

\item DO NOT CHANGE COMPILER DEFINES NOT RELATED TO THE LP SOLVER. Important 
note for OSL users: when using OSL in Windows, you must also add 
\texttt{OSLMSDLL} to the list of definitions.

\item Note that there are a number of additional preprocessor definitions that
control the functionality of \BB. These definitions are described in
\texttt{SYMPHONY-5.0/Makefile}, a Unix-style makefile included with the
distribution. To enable the functionality associated with a particular
definition, simply add it to the list of definitions, as above.

\item You must also be sure to have any \texttt{.dll} files required for your
LP solver to be in your search path. Either move the required \texttt{.dll} to
the subdirectory containing \texttt{symphony.exe} or add the path to the 
\texttt{PATH} Windows environment variable.

\item Once you have the proper settings for your LP solver, choose 
\texttt{Build symphony.exe} from the \texttt{Build menu}. This should 
successfully build the \BB\ library and the executable.

\item To test the executable, right click on the \texttt{symphony} project, go
to the \texttt{Debug} tab and set the program arguments to \texttt{-F
..$\backslash${sample.mps}} Note that command-line switches are Unix-style.

\item Now choose \texttt{Execute} from the build menu and the solver
should solve the sample problem.

\end{itemize}

Note that there is some functionality missing from the Windows version. Most
prominently, the timing functions do not work. This functionality
should be easy to add---let me know if you are interested in doing it and I
will give you all the help I can. In addition, the Windows version will only
run in sequential mode for a variety of reasons. However, it should be
relatively easy to get it running in parallel if you can get PVM working under
Windows. Let me know if you are interested.

\section{Using SYMPHONY}

\subsection{Using the SYMPHONY executable}

To use SYMPHONY as a generic solver, type the executable name followed by one
or more of the command-line switches. There are two required switches. You
must specify the location of the input file by using ``-F 'filename'.'' This
input file is assumed to be in MPS format, unless the ``-D'' switch is also
present, in which case the file will be assumed to be in GMPL model file
format with the data file specified after the ``-D'' switch. Some of
SYMPHONY's native parameters can also be set on the command line. Below is a
list of these parameters. This list can also be obtained by typing the
executable name with no command-line arguments. Note that all SYMPHONY
parameters are denoted by a lowercase letter. Note that there are dozens of
other parameters that can be set with the use of a parameter file. These
parameters are listed in the SYMPHONY user's manual.

\subsection{Using the SYMPHONY callable library}

To use SYMPHONY as a generic callable library, compile SYMPHONY as described
above. The library that is created along with the solver itself can be linked
to using the API described Section \ref{callable-library}. As an example of
using the callable library in this way, see the multi-criteria knapsack
application (MCKP).

\section{Compiling a Custom Application Using Callbacks}

\subsection{Unix}

First, configure and compile SYMPHONY 5.0 as described in
SYMPHONY-5.0/README-5.0. Modify the variables in the USER/Makefile
appropriately. Typing "make" in the USER subdirectory should successfully make
the USER executable. It will be installed in the directory
SYMPHONY-5.0/USER/bin.$(ARCH)/$(LP\_SOLVER).  After you've successfully
compiled the code, you can develop our custom application by following the
instructions for filling in the user callback functions as described in
Section \ref{SYMPHONY-development}.

\subsection{Microsoft Windows}

First, download \texttt{SYMPHONY-5.0.zip} and unzip the archive. This will
create a subdirectory called \texttt{SYMPHONY-5.0} containing all the source
files together with the \texttt{USER} subdirectory. There are two options to
get the executable. You can either compile on the command-line, using the
MSVC++ makefile,
\texttt{USER$\backslash$WIN32$\backslash$user.mak}, or you can use the 
provided projects and workspaces. However for the second option, it is 
important the \texttt{USER} archive be kept in the \texttt{SYMPHONY-5.0}
subdirectory or the project files will not work. Compiling on the 
command-line is somewhat easier since it requires only editing the makefile 
and typing a single command.

\subsection{Using the NMAKE Utility}

\begin{itemize}
\item 
Edit the \texttt{USER$\backslash$WIN32$\backslash$user.mak} makefile to reflect 
your environment. Only minor edits should be required. An explanation of 
what has to be set is contained in the comments in the makefile. This basically 
requires the same routines that one needs to walk through in 
\texttt{SYMPHONY}'s makefile. See the related parts of \ref{using_nmake} section 
of \texttt{SYMPHONY} above.

\item
Once configuration is done, type \texttt{nmake /f user.mak} in the 
\texttt{USER$\backslash$WIN32} subdirectory. The executable \texttt{user.exe} 
will be created under the \texttt{USER$\backslash$WIN32$\backslash$Debug} 
directory.

\item
To test the executable, type 
\texttt{user.exe -F ..$\backslash$..$\backslash$sample.mps} 
at a command prompt from the \texttt{USER$\backslash$WIN32$\backslash$Debug} 
directory. After this point, you will be ready to develop your own application 
by modifying the other files in the \texttt{USER} subdirectory.
\end{itemize}

\subsection{Using the MSVC++ Workspace}

\begin{itemize}
\item
In MS Visual C++ 6.0, open the workspace 
\texttt{SYMPHONY-5.0$\backslash$USER$\backslash$WIN32$\backslash$user.dsw}.
Note that there are two projects, one called \texttt{symphonyLib} and the other 
called \texttt{user}.The \texttt{symphonyLib} project compiles the source code, with the 
calls to the user-defined callbacks used to customize the solver, to create 
the callable library: \texttt{symphonyLib.lib}. The \texttt{user} 
project compiles those user callbacks together with the main function, links 
them with the callable library and creates the executable: \texttt{user.exe}.

\item 
The configuration steps are exactly the same with the MSVC++ section of 
\texttt{SYMPHONY}. The only 
difference is that, you have the \texttt{user} project instead of the
\texttt{symphony} project. Go through the related steps of section 
\ref{getting_started_windows} to see how to configure to use 
\texttt{COIN}, \texttt{OSI}, \texttt{CGL}, \texttt{COIN} utilities, 
\texttt{GMPL} input, and to change the lp solver which is by default 
\texttt{CLP}.

\item
Once you have the proper settings for your LP solver, choose \texttt{Build
user.exe} from the \texttt{Build} menu. This should successfully 
build the executable.

\item
To test the executable, right click on the \texttt{user} project, go to the
\texttt{Debug} tab and set the program arguments to 
\texttt{-F ..$\backslash$sample.mps}. Note that command-line switches are 
Unix-style.

\item
Now choose \texttt{Execute} from the build menu and you have a working branch
and bound solver! After sucessful compilation, you can fill in the user
callback functions as describe in Section{SYMPHONY-development}.
\end{itemize}

\section{Sample Applications}

There are a number of sample applications available as examples of how to do
development with \BB. These include solvers for the matching problem, the set
partitioning problem (simple and advanced versions), the vehicle routing and
traveling salesman problems, the mixed postman problem and, capacitated
network routing problem. These applications are distributed as separate
packages and can be downloaded from
\texttt{\htmladdnormallink{http://www.branchandcut.org/SYMPHONY}{http://www.branchandcut.org/SYMPHONY/}}. There is also a white paper that guides the
user through the development of the matching solver.

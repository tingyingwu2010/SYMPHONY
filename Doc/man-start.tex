BB\ (Single- or Multi-Process Optimization over Networks) Version 3.0.1
is a powerful environment for implementing branch, cut, and price
algorithms. The subroutines in the \BB\ library comprise a
state-of-the-art solver which is designed to be completely modular and
easy to port to various problem settings. All library subroutines are
generic---their implementation does not depend on the the
problem-setting. To develop a full-scale, parallel branch and cut
algorithm, the user has only to specify a few problem-specific
functions such as preprocessing and separation. The vast majority of
the computation takes place within a ``black box,'' of which the user
need have no knowledge. \BB\ communicates with the user's routines
through well-defined interfaces and performs all the normal functions
of branch and cut---tree management, LP solution, cut pool management,
as well as inter-process or inter-thread communication. Although there
are default options, the user can also assert control over the
behavior of \BB\ through a myriad of parameters and optional
subroutines. \BB\ can be built in a variety of configurations, ranging
from fully parallel to completely sequential, depending on the user's
needs. The library runs serially on almost any platform, and can also
run in parallel in either a fully distributed environment (network of
workstations) or shared-memory environment simply by changing a few
options in the make file. To run in a distributed environment, the
user must have installed {\em \htmladdnormallink{Parallel Virtual
Machine}{http://www.ccs.ornl.gov/pvm/}} (PVM) software, available for
free from Oak Ridge National Laboratories
\begin{latexonly}
at {\tt http://www.ccs.ornl.gov/pvm/} 
\end{latexonly}. 
To run in a shared memory environment, the user must have installed an
OpenMP compliant compiler. A cross-platform compiler called {\em
\htmladdnormallink{Omni}{http://pdplab.trc.rwcp.or.jp/Omni}}, which uses 
{\tt cc} or {\tt gcc} as a back end, is available for free download
\begin{latexonly}
at {\tt http://pdplab.trc.rwcp.or.jp/Omni}.
\end{latexonly}.
This section of the manual is concerned with the detailed
specifications needed to develop an application using \BB. It is
assumed that the user has already read the first part of the manual, which
provides a high-level introduction to parallel branch, cut, and price
and the overall design and use of \BB. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Compiling the Sample Application with Unix Operating Systems}
\label{getting_strated_unix}

Here is a sketch outline of how to get started with \BB\ in Unix. This is
basically the same information contained in the README file that comes with
the distribution and will lead you through the steps required to compile the
sample application, a VRP and TSP solver. Because \BB\ is intended to run over
nonhomogeneous networks of workstations, installation is not fully automated,
but requires the user to make minor edits to the makefile.  With this setup,
compilation for multiple architectures and configurations can be done in a
single directory without reconfiguring or ``cleaning.'' This is convenient on
nonhomogeneous networks, but it means that you might need to know a little
about your computing environment in order to make \BB\ compile. For the casual
user, this is limited to editing providing some path names. There may be some
complaints from the compiler because of missing function prototypes, etc.

\subsubsection{Preparing for Sample Compilation.}

\begin{itemize}

        \item Download the file {\tt SYMPHONY-3.0.1.tgz}.

        \item Unpack the distribution with ``{\tt tar -xzf
        SYMPHONY-3.0.1.tgz}''. This will create a subdirectory called
        {\tt SYMPHONY-3.0.1/} containing the distribution.
        
        \item Edit the makefile ({\tt SYMPHONY-3.0.1/Makefile}) to reflect your
	environment. Only minor edits should be required. An explanation of
	what has to be set is contained in the comments in the makefile.

\end{itemize}
        
\subsubsection{Compiling the Sequential Version.}

\begin{itemize}
        \item Type ``{\tt make}'' in the {\tt SYMPHONY-3.0.1/} directory. This will
first make the \BB\ library (sequential version). After making the \BB\
library, make will compile the user code and link the executable for the
sample application, a vehicle routing and traveling salesman problem
solver. The name of the executable will be 
\begin{center}
{\tt SYMPHONY-3.0.1/Vrp/bin.\$(ARCH)/master\_tm\_lp\_cg\_cp}, 
\end{center}
indicating that all
modules are contained in a single executable. The makefile must be modified to
enable parallel execution of the code.

\item After the code is compiled, you are free to type ``{\tt make
        clean}'' if you want to save disk space. You
        should only have to remake the library if you change something
        in \BB's internal files.

\item To test the sample program, a sample data file is included with the
distribution. Type 
\begin{center}
{\tt Vrp/bin.\$(ARCH)/master\_tm\_lp\_cg\_cp -F sample.vrp
-N 5 -u 522} 
\end{center}
in the {\tt SYMPHONY-3.0.1/} directory. The -N argument gives the number
of routes, which must be specified in advance. The -u argument supplies an
initial upper bound which is used until a better feasible solution is
found. TSP instances can also be solved by adding the option -T TSP. In the
case of the TSP, the number of routes does not need to be specified. You can
get additional problem data files from from \htmladdnormallink{\tt
http://branchandcut.org/VRP/data/}{http://branchandcut.org/VRP/data/} or the
\\ 
\htmladdnormallink{TSPLIB}
{http://www.iwr.uni-heidelberg.de/iwr/comopt/software/TSPLIB95/}
\begin{latexonly}
        (http://www.iwr.uni-heidelberg.de/iwr/comopt/software/TSPLIB95/)
\end{latexonly}. \\
The file
format is described on the TSPLIB Web site.
\end{itemize}

\subsubsection{Compiling the Shared Memory Version.}

\begin{itemize}
        \item To compile a shared memory version, obtain an OpenMP
        compliant compiler, such as \htmladdnormallink{Omni}
        {http://phase.etl.go.jp/Omni/}
\begin{latexonly} 
        (free from {\tt http://phase.etl.go.jp/Omni})
\end{latexonly}. 
        Other options are listed at \htmladdnormallink{the OpenMP Web
        site}{http://www.openmp.org}
\begin{latexonly}
        ({\tt http://www.openmp.org})
\end{latexonly}.

        \item Follow the instructions above for configuring the makefile. Set
the variable {\tt CC} to the compiler name in the make file and compile as
above. Note that if you have previously compiled the sequential version, then
you should first type {\tt make clean\_all}, as this version uses the same
directories.  With one thread allowed, it should run exactly the same as the
sequential version so there is no need to compile both versions.

        \item Voila, you have a shared memory parallel solver. As above, to
test the sample program, a sample data file is included with the
distribution. Type {\tt Vrp/bin.\$(ARCH)/master\_tm\_lp\_cg\_cp -F sample.vrp
-N 5 -u 522} in the {\tt SYMPHONY-3.0.1/} directory. The -N argument gives the number
of routes, which must be specified in advance. The -u argument supplies an
initial upper bound which is used until a better feasible solution is
found. TSP instances can also be solved by adding the option -T TSP. In the
case of the TSP, the number of routes does not need to be specified. You can
get additional problem data files from from \htmladdnormallink{\tt
http://branchandcut.org/VRP/data/} {http://branchandcut.org/VRP/data/} or the
\\ 
\htmladdnormallink{TSPLIB}
{http://www.iwr.uni-heidelberg.de/iwr/comopt/software/TSPLIB95/}
\begin{latexonly}
        (http://www.iwr.uni-heidelberg.de/iwr/comopt/software/TSPLIB95/)
\end{latexonly}. \\
The file format is described on the TSPLIB Web site.

\end{itemize}

\subsubsection{Compiling the Distributed Version.}

\begin{itemize}
        \item If you wish to compile a distributed version of the code, obtain
and install the {\em \htmladdnormallink{Parallel Virtual
Machine}{http://www.csm.ornl.gov/pvm/}} (PVM) software, available for free
from Oak Ridge National Laboratories
\begin{latexonly}
        at {\tt http://www.ccs.ornl.gov/pvm/}
\end{latexonly}. 
        See Section \ref{PVM} for more notes on using PVM.
        
        \item In the makefile, be sure to set the {\tt COMM\_PROTOCOL}
        variable to {\tt PVM}. Also, change one or more of {\tt
        COMPILE\_IN\_TM}, {\tt COMPILE\_IN\_LP}, {\tt COMPILE\_IN\_CG}, and
        {\tt COMPILE\_IN\_CP}, to {\tt FALSE}, or you will end up with the
        sequential version. Various combinations of these variables will give
        you different configurations and different executables. See Section
        \ref{configuration} for more info on setting them. Also, be sure to
        set the path variables in the make file appropriately so that make can
        find the PVM library.

        \item Type ``{\tt make}'' in the SYMPHPONY-3.0.1 directory to
        make the distributed libraries. As in Step 1 of the sequential
        version, you may type ``{\tt make clean}'' after making the
        library. It should not have to remade again unless you modify
        \BB's internal files.

        \item After the \BB\ libraries, user code will be compiled and
        required executables linked.

        \item Make sure there are links from your
        \$PVM\_ROOT/bin/\$PVM\_ARCH/ directory to each of the
        executables in the Vrp/bin.\$(ARCH) directory. This is required
        by PVM.

        \item Start the PVM daemon by typing ``{\tt pvm}'' on the command line
        and then typing ``{\tt quit}''.

        \item To test the sample program, a sample data file is included with
the distribution. Type {\tt Vrp/bin.\$(ARCH)/master -F sample.vrp -N 5 -u
522} in the {\tt SYMPHONY-3.0.1} directory (note that the actual executable name may
not be ``{\tt master}'' if {\tt COMPILE\_IN\_TM} is set to {\tt TRUE}; see
Section \ref{configuration} for more information on executable names.). The -N
argument gives the number of routes, which must be specified in advance. The
-u argument supplies an initial upper bound which is used until a better
feasible solution is found. TSP instances can also be solved by adding the
option -T TSP. In the case of the TSP, the number of routes does not need to
be specified. You can get additional problem data files from from
\htmladdnormallink{\tt http://branchandcut.org/VRP/data/}
{http://branchandcut.org/VRP/data/} or the \\
\htmladdnormallink{TSPLIB}
{http://www.iwr.uni-heidelberg.de/iwr/comopt/software/TSPLIB95/}
\begin{latexonly}
        (http://www.iwr.uni-heidelberg.de/iwr/comopt/software/TSPLIB95/)
\end{latexonly}. \\
The file
format is described on the TSPLIB Web site.

\end{itemize}

\noindent This should result in the successful compilation of the sample
application. Once you have accomplished this much, you are well on
your way to having an application of your own. Don't be daunted by the
seemingly endless list of user function that you are about to
encounter. Most of them are optional or have default options. If you
get lost, consult the source code for the sample application to see
how it's done.

\subsection{Compiling the Sample Application with Microsoft Windows}
\label{getting_strated_windows}

Here is a sketch outline of how to get started with \BB\ in Windows. This is
basically the same information contained in the README file that comes with
the distribution and will lead you through the steps required to compile the
sample application, a VRP and TSP solver. Direct support is provided for
compilation under MS Visual Studio 6.0. Compilation for other compilers should
also be possible. Note that the windows version has some limitations. Detailed
timing information is not currently provided.  Support is only provided for
running in sequential mode at this time.

\begin{itemize}

\item Download {\tt SYMPHONY-3.0.1.zip} and unzip the archive. This will
create a subdirectory called {\tt SYMPHONY-3.0.1$\backslash$} containing all 
the source files.

\item In MS Visual C++ 6.0, open the workspace 
{\tt SYMPHONY-3.0.1$\backslash$WIN32$\backslash$vrp.dsw}.  Note that
there are two projects, one called ``{\tt symphony}'' and one called ``{\tt
vrp}''.  The symphony project contains the source code needed to build the
internal library. The vrp project contains the source code for the
user-defined functions needed to build the sample application, a VRP and TSP
solver. Note that to develop a solver of your own, you would replace the VRP
library with one of your own.

\item By default, SYMPHONY is set up to use CPLEX 8.1 installed in a folder
called ``{\tt C:$\backslash$ILOG$\backslash$CPLEX81}''. To use a different LP 
solver or to specify a different location for CPLEX, there are a number of 
changes that need to be made.

\begin{itemize}

\item You must specify the name of and path to the library to be linked. Do 
this by right-clicking on the symphony project and choosing ``Add Files to
Project...'' Then locate the library file for the LP solver you are using
(either CPLEX or OSL). For CPLEX, you need the library called {\tt
cplex**.lib}, where ** is your CPLEX version.

\item You must set the include path for the solver header files. Do this
by right-clicking on the symphony project and choosing ``Settings...'' Then
choose the ``C/C++'' tab, and choose the category ``Preprocessor'' on the
drop-down menu.  Edit the path in the ``Additional include directories'' 
window.

\item You must set the compiler defines so that the right LP solver interface
will be used. Follow the procedure above to get to the preprocessor settings
and make sure that {\tt \_\_OSLLIB\_\_} is defined if you are using OSL or
{\tt \_\_CPLEX\_\_} is defined if you are using CPLEX. DO NOT CHANGE COMPILER
DEFINES NOT RELATED TO THE LP SOLVER. Important note for OSL users: When using
OSL in Windows, you must also define the symbol OSLMSDLL.

\end{itemize}

\item Note that there are a number of additional compiler defines that control
the functionality of SYMPHONY. These defines are described in {\tt
SYMPHONY-3.0.1$\backslash$Makefile}, a Unix-style make file included with the
distribution. To enable the functionality associated with a particular
compiler define, simply add it to the list of defines under the preprocessor
settings, as above.

\item You must also be sure to have any ``.dll'' files required for your LP 
solver to be in your search path. Either move the required .dll to the
directory containing symphony.exe or add the path to the ``{\tt PATH}''
Windows environment variable.

\item Once you have the proper settings for your LP solver, choose "Build
symphony.exe" from the ``Build'' menu. This should successfully build the
executable.

\item To test the executable, right click on the symphony project, go to the
``Debug'' tab and set the Program arguments to ``{\tt -F
SYMPHONY-3.0.1$\backslash$sample.vrp -N 5 -u 522.}'' Note that command-line
switches are Unix-style. The argument to -N is the number of routes that
should be used in the solution and the -u argument supplies the solver with an
initial upper bound.

\item Now choose ``Execute'' from the ``Build'' menu and the solver should 
solve the sample VRP file.

\item Note that there is some functionality missing from the Windows
version. Most prominently, the timing functions do not work. I suppose this
functionality should be easy to add. In addition, the Windows
version will only run in sequential mode for a variety of reasons. However, it
should be relatively easy to get it running in parallel if you can get PVM
working under Windows.

\end{itemize}

\subsection{Developing a New Application}

\subsubsection{Unix}

Developing a simple branch and bound solver can be done quite quickly using
the template provided in the \texttt{SYMPHONY/Template/}
directory. The simplest approach is to develop a sequential application,
sharing a single user data structure among all the modules. Using this
approach, an application can be developed by filling in only a few simple
functions. Here are four simple steps to get up and running.
\begin{enumerate}

\item Set the variable \texttt{USERROOT} in the make file to be
\texttt{\$(ROOT)/Template} and type "\texttt{make}". Assuming that the make
file has already been modified appropriately, as described in Section
\ref{getting_strated_windows}, this should successfully compile the template
code, although it will not run until it is modified as described below.

\item First, decide what run-time parameters you might need and what data has 
to be stored to describe your instance. Edit the file
\texttt{Template/include/user.h}, adding the appropriate fields to the
\texttt{user\_parameter} and \texttt{user\_problem} structure to store the
relevant values.

\item Now edit the file \texttt{Template/Master/master\_user.c}. If you choose
to have all variables in the base set (a good starting point), the only
function that really needs to be filled out initially is \texttt{user\_io()},
where you can read in the instance data. Note that the name of the file to
read the instance data from can be specified on the command line using the
"-F" switch.  Also, check out the function
\texttt{user\_set\_base()}.

\item Edit the file \texttt{Template/LP/lp\_user.c}. The function
\texttt{user\_create\_lp()} must be filled out. This is the most important
function, as it sets up the initial LP relaxation in each search node.
\end{enumerate}

Now compile by by typing ``\texttt{make}'' (assuming that the make
file has already been modified appropriately). That's it! You should now have
a working branch and bound solver. Next you can work on filling in more
advanced functions and adding cutting planes.

\subsubsection{Microsoft Windows}

Developing a simple branch and bound solver can be done quite quickly using
the template provided in the 
\texttt{SYMPHONY$\backslash$Template$\backslash$} directory. The
simplest approach is to develop a sequential application, sharing a single
user data structure among all the modules. Using this approach, an application
can be developed by filling in only a few simple functions. Here are four
simple steps to get up and running.
\begin{enumerate}

\item First open the workspace {\tt
SYMPHONY-3.0.1$\backslash$WIN32$\backslash$user.dsw} and modify for your local
setup, as described in Section \ref{getting_strated_windows}. It should
build right away, although it won't run until modified as described below.

\item First, decide what run-time parameters you might need and what data has 
to be stored to describe your instance. Edit the file
\texttt{Template$\backslash$include$\backslash$user.h}, adding the appropriate
fields to the \texttt{user\_parameter} and \texttt{user\_problem} structure to
store the relevant values.

\item Now edit the file
\texttt{Template$\backslash$Master$\backslash$master\_user.c}. If you choose to 
have all variables in the base set (a good starting point), the only function
that really needs to be filled out initially is \texttt{user\_io()}, where you
can read in the instance data. Note that the name of the file to read the
instance data from can be specified on the command line using the "-F" switch.
Also, check out the function
\texttt{user\_set\_base()}.

\item Edit the file \texttt{Template$\backslash$LP$\backslash$lp\_user.c}. The
function \texttt{user\_create\_lp()} must be filled out. This is the most
important function, as it sets up the initial LP relaxation in each search
node.
\end{enumerate}

Now build again and you have a working branch and bound solver! Next you can
work on filling in more advanced functions and adding cutting planes. See the
documentation for more information on this.


\documentclass[11pt]{article}

\setlength{\evensidemargin}{.25in}
\setlength{\oddsidemargin}{.25in}
\setlength{\textwidth}{6.0in}
\setlength{\parindent}{0in}
\setlength{\parskip}{0.1in}
\setlength{\topmargin}{0in}
\setlength{\textheight}{8.5in}

\usepackage{epsfig}
\usepackage{amssymb}

\newtheorem{theorem}{Theorem}
\newtheorem{acknowledgement}[theorem]{Acknowledgement}
\newtheorem{algorithm}[theorem]{Algorithm}
\newtheorem{axiom}[theorem]{Axiom}
\newtheorem{case}[theorem]{Case}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{conclusion}[theorem]{Conclusion}
\newtheorem{condition}[theorem]{Condition}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{criterion}[theorem]{Criterion}
\newtheorem{definition}{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{exercise}[theorem]{Exercise}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{notation}[theorem]{Notation}
\newtheorem{problem}[theorem]{Problem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{solution}[theorem]{Solution}
\newtheorem{summary}[theorem]{Summary}
\newenvironment{proof}[1][Proof]{\textbf{#1.} }{\ \rule{0.5em}{0.5em}}
\renewcommand{\Re}{\mathbb{R}}

\begin{document}

\title{Simple Walkthrough for Using SYMPHONY}
\author{Michael Trick\thanks{Graduate School of Industrial Administration,
Carnegie Mellon University, Pittsburgh, PA 15213 \texttt{trick@cmu.edu}, 
\texttt{http://mat.gsia.cmu.edu/trick}}}

\date{June 24, 2003}
\maketitle
\thispagestyle{empty}

SYMPHONY is a set of routines to allow the easy creation of a branch-cut-price
code using CPLEX or OSL as the underlying optimization engine. The SYMPHONY
system includes a sample application. The application, a vehicle routine code,
is extremely well done, but, in its generality, is difficult to understand.
Here is a walkthrough for a very simple application that uses SYMPHONY. Rather
than present the code in its final version, I will go through the steps that I
went through. Note that some of the code is lifted from the vehicle routine
code. This code is designed to be a sequential code.

Our goal is to create a minimum one-matching code on a complete graph.
Initially we will just formulate this as an integer program. Then we will
include a set of constraints that can be added by cut generation.

I begin with the "template" system included in SYMPHONY. This gives stubs for
each user routine. First I need to define the data needed for
one-matching. This data will be included in the structure \texttt{USER\_PROB}
in the file \texttt{user.h}.  Initially, the data will be the number of nodes
and the cost matrix, so change \texttt{USER\_PROB} in \texttt{user.h} to be

\begin{verbatim}
typedef struct USER_PROBLEM{
   int              colnum;         /* Number of rows in base matrix */
   int              rownum;         /* Number of columns in base matrix */
   user_parameters  par;            /* Parameters */
   int              nnodes;         /* Number of nodes */
   int              cost[200][200]; /* Cost of assigning i to j */ 
   int              node1[20000];
   int              node2[20000];
}user_problem;
\end{verbatim}

A ``real programmer'' would not hard-code problem sizes like that, but I am
trying to get a minimal code. The fields \texttt{node1} and \texttt{node2} will
be used later in the code in order to map constraints back to the
corresponding nodes.

Next, read in the data. The template already has a lot of flags set up. The
``-F'' flag defines the data file, so we will use that to put in the data. The
datafile contains first the number of nodes in the graph (\texttt{nnodes})
followed by the pairwise cost matrix (nnode by nnode). Read this in with the
\texttt{user\_io()} routine:

\begin{verbatim}
int user_io(void *user)
{
   /* This gives you access to the user data structure. */
   user_problem *prob = (user_problem *) user;
   user_parameters *par = &(prob->par);
   char *infile = par->infile;
   FILE *f = NULL;
   int i, j;

   if ((f = fopen(infile, "r")) == NULL){
      printf("Readparams: file %s can't be opened\n", infile);
      exit(1); /*error check for existence of parameter file*/
   }

   /* Read in the costs */
   fscanf(f,"%d",&(prob->nnodes));
   for (i = 0; i < prob->nnodes; i++)
      for (j = 0; j < prob->nnodes; j++)
         fscanf(f, "%d", &(prob->cost[i][j]));
   
   prob->colnum = (prob->nnodes)*(prob->nnodes-1)/2;
   prob->rownum = prob->nnodes;

   return(USER_NO_PP);
}
\end{verbatim}   

Note that we set the number of rows and columns in this routine. We can now
define the integer program. We will have a variable for each edge $(i,j)$ with
$i<j$. We have a constraint for each node $i$ forcing one edge to be incident
to $i$ in the matching.

We define the IP in \texttt{user\_create\_lp()} in \texttt{lp\_user.c}. This
routine needs to be sure the arrays are big enough, and I suspect easiest
would be to simply allocate them. This code checks current allocation and
reallocates as needed.
\newpage
\begin{verbatim}
int user_create_lp(void *user, int varnum, var_desc **vars, int rownum,
                   int cutnum, cut_data **cuts, int *nz, int **matbeg,
                   int **matind, double **matval, double **obj, double **rhs,
                   char **sense, double **rngval, int *maxn, int *maxm,
                   int *maxnz, int *allocn, int *allocm, int *allocnz)
{
   user_problem *prob = (user_problem *) user;
   int i, j, index;
   int resize;

   /* set up the inital LP data */

   *nz = 2 * varnum;

   /* We have to check to make sure there is enough space allocated
      for the matrix we are going to build */
   if (2 * rownum > *maxm){
      *maxm = 2 * rownum;
      resize = TRUE;
   }
   
   /* Allocate space for all edges up front since we have small problems */
   if (prob->colnum != *maxn){
      *maxn = prob->colnum;
      resize = TRUE;
   }
   
   if (*nz + ((*maxm) * (*maxn) / 10) > *maxnz){
      *maxnz = *nz + ((*maxm) * (*maxn) / 10);
      resize = TRUE;
   }
   
   /* If there was not enough space, the allocate more */
   if (resize){
      /*re-malloc all the arrays*/
      FREE(*matbeg);
      FREE(*matind);
      FREE(*matval);
      FREE(*obj);
      FREE(*rhs);
      FREE(*sense);
      FREE(*rngval);
      *allocm  = *maxm;
      *allocn  = *maxm + *maxn + 1;
      *allocnz = *maxnz + *maxm;
      *matbeg  = (int *) malloc(*allocn * ISIZE);
      *matind  = (int *) malloc(*allocnz * ISIZE);
      *matval  = (double *) malloc(*allocnz * DSIZE);
      *obj     = (double *) malloc(*allocn * DSIZE);
      *rhs     = (double *) malloc(*allocm * DSIZE);
      *sense   = (char *) malloc(*allocm * CSIZE);
      *rngval  = (double *) calloc(*allocm, DSIZE);
   }
   
   /* Fill out the appropriate data structures -- each column has
      exactly two entries */
   index = 0;
   for (i = 0; i < prob->nnodes; i++) {
      for (j = i+1; j < prob->nnodes; j++) {
         prob->node1[index] = i; /* The first node of assignment 'index' */
         prob->node2[index] = j; /* The second node of assignment 'index' */
         (*obj)[index] = prob->cost[i][j]; /* Cost of assignment (i, j) */
         (*matbeg)[index] = 2*index;
         (*matval)[2*index] = 1;
         (*matval)[2*index+1] = 1;
         (*matind)[2*index] = i;
         (*matind)[2*index+1] = j;
         index++;
      }
   }
   (*matbeg)[varnum] = 2*varnum;
   
   /* set the initial right hand side */
   for (i = 0; i < prob->nnodes; i++) {
      (*rhs)[i] = 1;
      (*sense)[i] = 'E';
   }
   return(USER_NO_PP);
}      
\end{verbatim}

OK, that's it. That defines an integer program, and if you compile and
optimize it, the rest of the system will come together to solve this problem.
Here is a data file to use:
\begin{verbatim}
6
0 1 1 3 3 3
1 0 1 3 3 3
1 1 0 3 3 3
3 3 3 0 1 1
3 3 3 1 0 1
3 3 3 1 1 0
\end{verbatim}

The optimal value is 5. To display the solution, we need to be able to map
back from variables to the nodes. That was the use of the \texttt{node1} and
\texttt{node2} parts of the \texttt{USER\_DATA}. We can now use
\texttt{user\_display\_solution()} to print out the solution:

\begin{verbatim}
int user_display_solution(void *user, int length, int *xind, double *xval)
{
   /* This gives you access to the user data structure. */
   user_problem *prob = (user_problem *) user;
   int index;
 
   for (index = 0; index < length; index++){
      if (xval[index] > 0) {
         printf("%2d matched with %2d at cost %6d\n",prob->node1[xind[index]],
                prob->node2[xind[index]],
                prob->cost[prob->node1[xind[index]]][prob->node2[xind[index]]]);
      }	   
   }
   
   return(USER_NO_PP);
}
\end{verbatim}

We will now update the code to include a crude cut generation. Of course, I am
eventually aiming for a Gomory-Hu type odd-set separation (ala Groetschel and
Padberg) but for the moment, let's just check for sets of size three with more
than value 1 among them (such a set defines a cut that requires at least one
edge out of any odd set). We can do this by brute force checking of triples.

This is done it two steps: first, we find cuts and store them as we wish. Then
we ``unpack'' the cuts and create the violated inequalities. Finding the cuts
is in the routine \texttt{user\_find\_cuts()} in \texttt{cg\_user.c}. In the
following ``cuts'' is an array which is zero except for \texttt{cut[i]},
\texttt{cut[j]} and \texttt{cut[k]} (where \texttt{i}, \texttt{j}, and
\texttt{k} represents the violating triple) which are ``1.''

\begin{verbatim}
int user_find_cuts(void *user, int varnum, int iter_num, int level,
                   int index, double objval, int *indices, double *values,
                   double ub, double etol, int *cutnum)
{
   user_problem *prob = (user_problem *) user;
   double edge_val[200][200]; /* Matrix of edge values */
   int i, j, k, index;
   int *cuts;
   cut_data cut;
   
   *cutnum = 0;

   cuts = malloc(prob->nnodes * ISIZE);

   /* Allocate the edge_val matrix to zero (we could also just calloc it) */
   memset(edge_val, 0, 200*200*ISIZE);
   
   for (index = 0; index < varnum; index++) {
      edge_val[prob->node1[indices[index]]][prob->node2[indices[index]]] 
         = values[index];
   }
   for (i = 0; i < prob->nnodes; i++){
      for (j = i+1; j < prob->nnodes; j++){
         for (k = j+1; k < prob->nnodes; k++) {
            if (edge_val[i][j]+edge_val[j][k]+edge_val[i][k] > 1.0 + etol) {
               memset(cuts, 0, prob->nnodes * ISIZE);
               cuts[i] = 1; 
               cuts[j] = 1;
               cuts[k] = 1;
               cut.size = (prob->nnodes)*ISIZE;
               cut.coef = (char *) cuts;
               cut.rhs = 1.0;
               cut.range = 0.0;
               cut.type = TRIANGLE;
               cut.sense = 'L';
               cut.deletable = TRUE;
               cut.branch = ALLOWED_TO_BRANCH_ON;
               cg_send_cut(&cut);
               (*cutnum)++;
	    }
	 }
      }
   }
   
   FREE(cuts);

   return(USER_NO_PP);
}
\end{verbatim}

Note the call of \texttt{cg\_send\_cut()}, which tells the system about any
cuts found.

The final step is to give a routine that creates cuts from the structure
defined in \texttt{user\_find\_cuts()}. This is the routine
\texttt{user\_unpack\_cuts()} in \texttt{lp\_user.c}. The levels of
indirection here are somewhat confusing (I don't think I have seen a ***
variable before), but the mallocs in the following create things in the right
order:
\newpage
\begin{verbatim}
int user_unpack_cuts(void *user, int from, int type, int varnum,
		     var_desc **vars, int cutnum, cut_data **cuts,
		     int *new_row_num, waiting_row ***new_rows)
{
   user_problem *prob = (user_problem *) user;
   
   int i, j, nzcnt;
   int *cutval;
   waiting_row **row_list;
   
   *new_row_num = cutnum;
   if (cutnum > 0)
      *new_rows =
	 row_list = (waiting_row **) calloc (cutnum*sizeof(waiting_row *));
   
   for (j = 0; j < cutnum; j++){
      row_list[j] = (waiting_row *) malloc(sizeof(waiting_row));
      switch (cuts[j]->type){
	 
      case TRIANGLE:
	 cutval = (int *) (cuts[j]->coef);
	 row_list[j]->cut = cuts[j];
	 row_list[j]->matind = (int *) malloc(varnum * ISIZE);
	 row_list[j]->matval = (double *) malloc(varnum * DSIZE);
	 row_list[j]->nzcnt = 0;
	 for (nzcnt = 0, i = 0; i < varnum; i++){
	    if (cutval[prob->node1[vars[i]->userind]] &&
		cutval[prob->node2[vars[i]->userind]]){
	       row_list[j]->matval[nzcnt] = 1.0;
	       row_list[j]->matind[nzcnt++] = vars[i]->userind;
	    }
	 }
	 row_list[j]->nzcnt = nzcnt;
	 break;

       default:
	 printf("Unrecognized cut type!\n");
      }
   }
   
   return(USER_NO_PP);
}
\end{verbatim}

If you now solve the matching problem on the sample data set, the number of
nodes in the branch and bound tree should just be 1 (rather than 3 without cut
generation).

\end{document}

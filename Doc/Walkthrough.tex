\documentclass[11pt]{article}

\setlength{\evensidemargin}{.25in}
\setlength{\oddsidemargin}{.25in}
\setlength{\textwidth}{6.0in}
\setlength{\parindent}{0in}
\setlength{\parskip}{0.1in}
\setlength{\topmargin}{0in}
\setlength{\textheight}{8.5in}

\usepackage{epsfig}
\usepackage{amssymb}

\newtheorem{theorem}{Theorem}
\newtheorem{acknowledgement}[theorem]{Acknowledgement}
\newtheorem{algorithm}[theorem]{Algorithm}
\newtheorem{axiom}[theorem]{Axiom}
\newtheorem{case}[theorem]{Case}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{conclusion}[theorem]{Conclusion}
\newtheorem{condition}[theorem]{Condition}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{criterion}[theorem]{Criterion}
\newtheorem{definition}{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{exercise}[theorem]{Exercise}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{notation}[theorem]{Notation}
\newtheorem{problem}[theorem]{Problem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{solution}[theorem]{Solution}
\newtheorem{summary}[theorem]{Summary}
\newenvironment{proof}[1][Proof]{\textbf{#1.} }{\ \rule{0.5em}{0.5em}}
\renewcommand{\Re}{\mathbb{R}}

\begin{document}

\title{Simple Walkthrough for Using SYMPHONY}
\author{Michael Trick\thanks{Graduate School of Industrial Administration,
Carnegie Mellon University, Pittsburgh, PA 15213 \texttt{trick@cmu.edu}, 
\texttt{http://mat.gsia.cmu.edu/trick}}}

\date{June 24, 2003}
\maketitle
\thispagestyle{empty}

SYMPHONY is a set of routines to allow the easy creation of a branch-cut-price
code using CPLEX or OSL underlying optimization engine directly or the 
COIN-OSI interface to call the mathematical programming solvers such as CLP, 
CPLEX, DYLP, GLPK, OSL, SOPLEX, VOL and XPRESS-MP. The SYMPHONY system 
includes a few sample applications: Vehicle Routing Problem (VRP), Mixed 
Postman Problem (MPP), Set Partitioning Problems (SPP-basic and advanced). 
These applications are extremely well done, but, in generality, are difficult 
to understand.

Here is a walkthrough for a very simple application that uses SYMPHONY. Rather
than presenting the code in its final version, I will go through the steps 
that I went through. Note that some of the code is lifted from the vehicle 
routing application. This code is designed to be a sequential code. The MATCH application itslef is available for download at 
\texttt{http://www.branchandcut.org/MATCH}. 

Our goal is to create a minimum one-matching code on a complete graph.
Initially we will just formulate this as an integer program. Then we will
include a set of constraints that can be added by cut generation.

I begin with the template file in the \texttt{USER} subdirectory included in
SYMPHONY. This gives stubs for each user routine. First I need to define the
data needed for one-matching. This data will be included in the structure
\texttt{USER\_PROBLEM} in the file \texttt{user.h}.  Initially, the data will
be the number of nodes and the cost matrix, so change \texttt{USER\_PROBLEM}
in \texttt{user.h} to be

\begin{verbatim}
typedef struct USER_PROBLEM{
   int              colnum;         /* Number of rows in base matrix */
   int              rownum;         /* Number of columns in base matrix */
   user_parameters  par;            /* Parameters */
   int              nnodes;         /* Number of nodes */
   int              cost[200][200]; /* Cost of assigning i to j */ 
   int              node1[20000];   /* First index of each variable */
   int              node2[20000];   /* Second index of each variable */
}user_problem;
\end{verbatim}

A ``real programmer'' would not hard-code problem sizes like that, but I am
trying to get a minimal code. The fields \texttt{node1} and \texttt{node2} will
be used later in the code in order to map constraints back to the
corresponding nodes.

Next, read in the data. The template already has a lot of flags set up. The
``-F'' flag defines the data file, so we will use that to put in the data. The
datafile contains first the number of nodes in the graph (\texttt{nnodes})
followed by the pairwise cost matrix (nnode by nnode). Read this in with the
\texttt{user\_io()} routine:

\begin{verbatim}
int user_io(void *user)
{
   /* This gives you access to the user data structure. */
   user_problem *prob = (user_problem *) user;
   user_parameters *par = &(prob->par);
   char *infile = par->infile;
   FILE *f = NULL;
   int i, j;

   if ((f = fopen(infile, "r")) == NULL){
      printf("Readparams: file %s can't be opened\n", infile);
      return(USER_ERROR); /*error check for existence of parameter file*/
   }

   /* Read in the costs */
   fscanf(f,"%d",&(prob->nnodes));
   for (i = 0; i < prob->nnodes; i++)
      for (j = 0; j < prob->nnodes; j++)
         fscanf(f, "%d", &(prob->cost[i][j]));
   
   prob->colnum = (prob->nnodes)*(prob->nnodes-1)/2;
   prob->rownum = prob->nnodes;

   return(USER_SUCCESS);
}
\end{verbatim}   

Note that we set the number of rows and columns in this routine. We can now
define the integer program. We will have a variable for each edge $(i,j)$ with
$i<j$. We have a constraint for each node $i$ forcing one edge to be incident
to $i$ in the matching.

We define the IP in \texttt{user\_create\_subproblem()} in
\texttt{user\_lp.c}. This routine needs to be sure the arrays are big enough,
and I suspect easiest would be to simply allocate them. Note that the arrays
are the members of \texttt{LPdesc} structure which carries the user defined
problem description. This code checks current allocation and reallocates as
needed.
\newpage
\begin{verbatim}
int user_create_subproblem(void *user, int *indices, MIPdesc *mip, 
                           int *maxn, int *maxm, int *maxnz)
{
   user_problem *prob = (user_problem *) user;
   int i, j, index;

   /* set up the inital LP data */

   mip->nz = 2 * mip->n;

   /* Estimate the maximum number of nonzeros */
   *maxm = 2 * mip->m;
   *maxn = mip->n;
   *maxnz = mip->nz + ((*maxm) * (*maxn) / 10);
   
   /* Allocate the arrays. These are owned by SYMPHONY after returning. */
   mip->matbeg  = (int *) malloc((mip->n + 1) * ISIZE);
   mip->matind  = (int *) malloc((mip->nz) * ISIZE);
   mip->matval  = (double *) malloc((mip->nz) * DSIZE);
   mip->obj     = (double *) malloc(mip->n * DSIZE);
   mip->lb      = (double *) calloc(mip->n, DSIZE);
   mip->ub      = (double *) malloc(mip->n * DSIZE);
   mip->rhs     = (double *) malloc(mip->m * DSIZE);
   mip->sense   = (char *) malloc(mip->m * CSIZE);
   mip->rngval  = (double *) calloc(mip->m, DSIZE);
   mip->is_int  = (char *) malloc(mip->n * CSIZE);
   
   /* Fill out the appropriate data structures -- each column has
      exactly two entries*/
   index = 0;
   for (i = 0; i < prob->nnodes; i++) {
      for (j = i+1; j < prob->nnodes; j++) {
         prob->node1[index] = i; /* The first node of assignment 'index' */
         prob->node2[index] = j; /* The second node of assignment 'index' */
         mip->obj[index] = prob->cost[i][j]; /* Cost of assignment (i, j) */
	 mip->is_int[index] = TRUE;
         mip->matbeg[index] = 2*index;
         mip->matval[2*index] = 1;
         mip->matval[2*index+1] = 1;
         mip->matind[2*index] = i;
         mip->matind[2*index+1] = j;
	 mip->ub[index] = 1.0;
         index++;
      }
   }
   mip->matbeg[mip->n] = 2 * mip->n;
   
   /* set the initial right hand side */
   for (i = 0; i < prob->nnodes; i++) {
      mip->rhs[i] = 1;
      mip->sense[i] = 'E';
   }

   return(USER_SUCCESS);
}      
\end{verbatim}

OK, that's it. That defines an integer program, and if you compile and
optimize it, the rest of the system will come together to solve this problem.
Here is a data file to use:
\begin{verbatim}
6
0 1 1 3 3 3
1 0 1 3 3 3
1 1 0 3 3 3
3 3 3 0 1 1
3 3 3 1 0 1
3 3 3 1 1 0
\end{verbatim}

The optimal value is 5. To display the solution, we need to be able to map
back from variables to the nodes. That was the use of the \texttt{node1} and
\texttt{node2} parts of the \texttt{USER\_PROBLEM}. We can now use
\texttt{user\_display\_solution()} to print out the solution:

\begin{verbatim}
int user_display_solution(void *user, double lpetol, int varnum, int *indices,
                          double *values, double objval)
{
   /* This gives you access to the user data structure. */
   user_problem *prob = (user_problem *) user;
   int index;
 
   for (index = 0; index < varnum; index++){
      if (values[index] > lpetol) {
          printf("%2d matched with %2d at cost %6d\n",
                prob->node1[indices[index]],
                prob->node2[indices[index]],
                prob->cost[prob->node1[indices[index]]]
                [prob->node2[indices[index]]]);
      }	   
   }
   
   return(USER_SUCCESS);
}
\end{verbatim}

We will now update the code to include a crude cut generation. Of course, I am
eventually aiming for a Gomory-Hu type odd-set separation (ala Groetschel and
Padberg) but for the moment, let's just check for sets of size three with more
than value 1 among them (such a set defines a cut that requires at least one
edge out of any odd set). We can do this by brute force checking of triples.

This is done in two steps: first, we find cuts and store them as we wish. Then
we ``unpack'' the cuts and create the violated inequalities. Finding the cuts
is in the routine \texttt{user\_find\_cuts()} in \texttt{user\_cg.c}. In the
following ``cuts'' is an array which is zero except for \texttt{cut[i]},
\texttt{cut[j]} and \texttt{cut[k]} (where \texttt{i}, \texttt{j}, and
\texttt{k} represents the violating triple) which are ``1.''

\begin{verbatim}
int user_find_cuts(void *user, int varnum, int iter_num, int level,
                   int index, double objval, int *indices, double *values,
                   double ub, double etol, int *cutnum, char *status)
{
   user_problem *prob = (user_problem *) user;
   double edge_val[200][200]; /* Matrix of edge values */
   int i, j, k;
   int *cuts;
   cut_data cut;
   
   *cutnum = 0;

   cuts = (int *) malloc(prob->nnodes * ISIZE);

   /* Allocate the edge_val matrix to zero (we could also just calloc it) */
   memset((char *)edge_val, 0, 200*200*ISIZE);
   
   for (i = 0; i < varnum; i++) {
      edge_val[prob->node1[indices[i]]][prob->node2[indices[i]]] 
         = values[i];
   }
   for (i = 0; i < prob->nnodes; i++){
      for (j = i+1; j < prob->nnodes; j++){
         for (k = j+1; k < prob->nnodes; k++) {
            if (edge_val[i][j]+edge_val[j][k]+edge_val[i][k] > 1.0 + etol) {
               memset(cuts, 0, prob->nnodes * ISIZE);
               cuts[i] = 1; 
               cuts[j] = 1;
               cuts[k] = 1;
               cut.size = (prob->nnodes)*ISIZE;
               cut.coef = (char *) cuts;
               cut.rhs = 1.0;
               cut.range = 0.0;
               cut.type = TRIANGLE;
               cut.sense = 'L';
               cut.deletable = TRUE;
               cut.branch = ALLOWED_TO_BRANCH_ON;
               cg_send_cut(&cut);
               (*cutnum)++;
            }
         }
      }
   }
   
   FREE(cuts);

   return(USER_SUCCESS);
}
\end{verbatim}

Note the call of \texttt{cg\_send\_cut()}, which tells the system about any
cuts found.

The final step is to give a routine that creates cuts from the structure
defined in \texttt{user\_find\_cuts()}. This is the routine
\texttt{user\_unpack\_cuts()} in \texttt{user\_lp.c}. The levels of
indirection here are somewhat confusing (I don't think I have seen a ***
variable before), but the mallocs in the following create things in the right
order:
\begin{verbatim}
int user_unpack_cuts(void *user, int from, int type, int varnum,
                     var_desc **vars, int cutnum, cut_data **cuts,
                     int *new_row_num, waiting_row ***new_rows)
{
   user_problem *prob = (user_problem *) user;
   
   int i, j, nzcnt;
   int *cutval;
   waiting_row **row_list;
   
   *new_row_num = cutnum;
   if (cutnum > 0)
      *new_rows =
          row_list = (waiting_row **) calloc (cutnum, sizeof(waiting_row *));
   
   for (j = 0; j < cutnum; j++){
      row_list[j] = (waiting_row *) malloc(sizeof(waiting_row));
      switch (cuts[j]->type){
	 
      case TRIANGLE:
         cutval = (int *) (cuts[j]->coef);
         row_list[j]->matind = (int *) malloc(varnum * ISIZE);
         row_list[j]->matval = (double *) malloc(varnum * DSIZE);
         row_list[j]->nzcnt = 0;
         for (nzcnt = 0, i = 0; i < varnum; i++){
            if (cutval[prob->node1[vars[i]->userind]] &&
                cutval[prob->node2[vars[i]->userind]]){
               row_list[j]->matval[nzcnt] = 1.0;
               row_list[j]->matind[nzcnt++] = vars[i]->userind;
            }
         }
         row_list[j]->nzcnt = nzcnt;
         break;

       default:
           printf("Unrecognized cut type!\n");
      }
   }
   
   return(USER_SUCCESS);
}
\end{verbatim}

If you now solve the matching problem on the sample data set, the number of
nodes in the branch and bound tree should just be 1 (rather than 3 without cut
generation).

\end{document}
